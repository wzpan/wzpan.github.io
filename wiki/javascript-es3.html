<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>ES3 | HaHack</title>
  <meta name="author" content="wzpan">
  
  <meta name="description" content="JavaScript 是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。
JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="ES3"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="//atom.xml" title="HaHack" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" id="theme" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/bubble.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/article.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css"> -->
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
    <![endif]-->

  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery-2.0.3.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.pjax.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/pace.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/theme.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/search.js"></script>
  
    
    <link rel="stylesheet" href="/css/gitalk.css">
    <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/gitalk.min.js"></script>
    
  <script type="text/javascript">
    $(document).ready(function() {
      $(document).pjax('a[target!=_blank][rel!=gallery]', '.pjax', {fragment:'.pjax', timeout:8000});
    });

    $(document).on('pjax:send', function() {
	  Pace.restart();
    })
    $(document).on('pjax:complete', function() {
       Pace.stop();
        
       var search_path = "search.xml";
	   if (search_path.length == 0) {
	 	search_path = "search.xml";
	   }
	   var path = '/' + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');

       $('[data-spy="affix"]').each(function () {
          var $spy = $(this)
          , data = $spy.data()
          data.offset = data.offset || {}
          data.offsetBottom && (data.offset.bottom = data.offsetBottom)
          data.offsetTop && (data.offset.top = data.offsetTop)
          $spy.affix(data)
       });

    })
    $(document).on({'pjax:end': function() {
      $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function() { 
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
                tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
                TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
                messageStyle: "none"
            });

            var math = document.getElementsByClassName("pjax")[0];
            MathJax.Hub.Queue(["Typeset",MathJax.Hub,math]);
            
        });
        $.getScript("//hahack-1253537070.file.myqcloud.com/images/blog/js/gallery.js");
        if ($('#gitalk-container').length > 0) {
            var gitalk = new Gitalk({
                clientID: '19f93019e0c0b8fdc4b3',
                clientSecret: '00ca18ff55f2b4f0f33af3fb90ff524e7acd1032',
                id: undefined != undefined ? 'undefined' : window.location.pathname,
                repo: 'wzpan.github.io',
                owner: 'wzpan',
                admin: 'wzpan',
                proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
                title: 'ES3'
            })
            gitalk.render('gitalk-container');
        }
      }
    })
  </script>
  <!-- analytics -->
  



<meta name="generator" content="Hexo 5.4.0"></head>

 <body data-spy="scroll" data-target=".wiki .toc">
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">HaHack</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archive" title="所有文章存档">
			  <i class="fas fa-archive"></i>Archive
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="所有文章分类.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="所有文章标签.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/wiki" title="我的笔记库">
			  <i class="fa fa-tasks"></i>wiki
			</a>
		  </li>
		  
		</ul>
        <ul class="nav navbar-nav navright">
          <li class="dropdown works">
          <a href="#" title="更换主题" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><i class="fa fa-palette"></i></a>
          <ul class="dropdown-menu">
            
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-cerulean" title="更换颜色主题为cerulean"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#0B4C8D"></span>cerulean</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-cyborg" title="更换颜色主题为cyborg"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#272B30"></span>cyborg</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-paper" title="更换颜色主题为paper"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#2B97F0"></span>paper</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-flatly" title="更换颜色主题为flatly"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#28BB9C"></span>flatly</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-journal" title="更换颜色主题为journal"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#E96967"></span>journal</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-simplex" title="更换颜色主题为simplex"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#D7261E"></span>simplex</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-spacelab" title="更换颜色主题为spacelab"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#507DAC"></span>spacelab</a></li> 
			
          </ul>
          </li>
          <li class="dropdown works">
          <a href="#" title="作品集" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Works <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/wukong-robot" title="wukong-robot 是一个简单、灵活、优雅的中文语音对话机器人。"><i class="fab fa-github"></i>wukong-robot</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/dingdang-robot/dingdang-robot" title="叮当是一款可以工作在 Raspberry Pi 上的中文语音对话机器人/智能音箱项目。"><i class="fab fa-github"></i>dingdang-robot</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/comment.js" title="纯JS实现的静态站点评论系统，使用 Github/OSChina 作为 backend。"><i class="fab fa-github"></i>comment.js</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/qtevm" title="首个完整的 C++ 开源实现，能同时放大动作变化和颜色变化"><i class="fab fa-github"></i>QtEVM</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/hexo-series" title="为 Hexo 写的一系列主题/工具/插件"><i class="fab fa-github"></i>hexo-series</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/scnu/scnuthesis" title="符合华南师范大学硕士/博士学位论文格式要求的LaTeX模板。"><i class="fab fa-github"></i>SCNUThesis</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/slides" title="一些幻灯片作品"><i class="fab fa-github"></i>Slides</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://www.hahack.com/codes/fcevm/" title="硕士毕业论文"><i class="fab fa-github"></i>Dissertation</a></li>
			
            <li role="separator" class="divider"></li>
            
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/list/python%20next%20潘伟洲" title="Python 从入门到实践系列"><i class="fas fa-video"></i>Python</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/350627" title="使用Cocos Creator开发微信小游戏《2048》"><i class="fas fa-video"></i>2048</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/326820" title="微信小游戏入门与实战"><i class="fas fa-video"></i>minigame</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/471888?_bid=167&_wv=3&term_id=100565039&taid=4061608838378320" title="微信小游戏入门与实战"><i class="fas fa-video"></i>IT大咖说</a></li> 
			
          </ul>
          </li>
          <li class="dropdown works">
            <a href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Subscribe <span class="caret"></span></a>
            <ul class="dropdown-menu">
              
			    <li role="presentation"><a role="menuitem" tabindex="-1"  href="/atom.xml"  title="使用 RSS 阅读器订阅 HaHack"  ><i class="fa fa-rss-square"></i>RSS</a></li>
			  
			    <li role="presentation"><a role="menuitem" tabindex="-1"  title="订阅 HaHack 的公众平台"  data-toggle="modal" data-target="#wechat-modal" ><i class="fa fa-qrcode"></i>WeChat</a></li>
			  
			    <li role="presentation"><a role="menuitem" tabindex="-1"  target="_blank" rel="noopener" href="http://toutiao.io/u/147640"  title=""  ><i class="fa fa-align-justify"></i>Toutiao</a></li>
			   
            </ul>
          </li>
          
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   	  	  
        </ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content pjax">
      

	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> ES3</h1>
		</div>		
	



<div class="row wiki">
	<!-- span -->
    
        <div class="col-md-3 toc" id="toc">
             <!-- toc -->
		     
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
           generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



        </div>
        <div class="col-md-9 note">
    

	

		<!-- content -->
		<p>JavaScript 是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。</p>
<p>JavaScript 由 Brendan Eich 发明。它于 1995 年出现在 Netscape 中（该浏览器已停止更新），并于 1997 年被 ECMA（一个标准协会）采纳。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为ECMAScript，这个版本就是1.0版。</p>
<h2 id="ECMAScript的前世今生">ECMAScript的前世今生</h2>
<ul>
<li>大概在 1992 年，一家称作 Nombas 的公司开发了一种叫做 C 减减（C-minus-minus，简称 Cmm）的嵌入式脚本语言。这个脚本语言捆绑在一个叫做 CEnvi 的共享软件中，它首次向开发人员展示了这种语言的威力。Nombas 又把 Cmm 的名字改成了 ScriptEase。</li>
<li>当 Netscape Navigator 崭露头角时，Nombas 开发了一个可以嵌入网页中的 CEnvi 的版本。</li>
<li>当时工作于 Netscape 的 Brendan Eich，开始着手为即将在 1995 年发行的 Netscape Navigator 2.0 开发一个称之为 LiveScript 的脚本语言，当时的目的是在浏览器和服务器（本来要叫它 LiveWire）端使用它。Netscape 与 Sun 及时完成 LiveScript 实现。</li>
<li>Netscape Navigator 2.0 即将正式发布前，Netscape 将其更名为 JavaScript，目的是为了利用 Java 这个因特网时髦词汇。Netscape 的赌注最终得到回报，JavaScript 从此变成了因特网的必备组件。</li>
<li>眼看 JavaScript 1.0 如此成功，微软也跟着发布了 IE 3.0 并搭载了一个 JavaScript 的克隆版，叫做 JScript。在微软进入后，有 3 种不同的 JavaScript 版本同时存在：Netscape Navigator 3.0 中的 JavaScript、IE 中的 JScript 以及 CEnvi 中的 ScriptEase。JavaScript 标准化呼之欲出。</li>
<li>1997 年，JavaScript 1.1 作为一个草案提交给欧洲计算机制造商协会（ECMA），希望能推动 JavaScript 的标准化。同年，ECMA 发布 ECMAScript 1.0 。</li>
<li>1998年6月，ECMA 发布 ECMAScript 2.0 。</li>
<li>1999年12月，ECMA 发布 ECMAScript 3.0 。3.0版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了JavaScript语言的基本语法。直到今天，初学者一开始学习JavaScript，其实就是在学 3.0 版的语法。</li>
<li>2000年，ECMAScript 4.0 开始酝酿。这个版本由于太激进，最后没有通过。ECMA开会决定，中止ECMAScript 4.0的开发，将其中涉及现有功能改善的一小部分，发布为ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为Harmony（和谐）。会后不久，ECMAScript 3.1就改名为ECMAScript 5。</li>
<li>2009年，ECMAScript 5.0版正式发布。Harmony项目则一分为二，一些较为可行的设想定名为JavaScript.next继续开发，后来演变成ECMAScript 6；一些不是很成熟的设想，则被视为JavaScript.next.next，在更远的将来再考虑推出。</li>
<li>2011年6月，ECMAscript 5.1版发布，成为国际标准。</li>
<li>2015年6月，ECMAScript 6 正式通过，成为国际标准。</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<h3 id="ECMAScript">ECMAScript</h3>
<p>尽管 ECMAScript 是一个重要的标准，但它并不是 JavaScript 唯一的部分，当然，也不是唯一被标准化的部分。实际上，一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：</p>
<ul>
<li>JavaScript 的核心 ECMAScript 描述了该语言的语法和基本对象；</li>
<li>DOM 描述了处理网页内容的方法和接口；</li>
<li>BOM 描述了与浏览器进行交互的方法和接口。</li>
</ul>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/js-structure.gif" alt="JavaScript的组成部分" />
        <figcaption>JavaScript的组成部分</figcaption>
      </figure>
    </p>
<p>简单地说，ECMAScript 描述了以下内容：</p>
<ul>
<li>语法</li>
<li>类型</li>
<li>语句</li>
<li>关键字</li>
<li>保留字</li>
<li>运算符</li>
<li>对象</li>
</ul>
<p>ECMAScript 是一个标准的描述，定义了脚本语言的所有属性、方法和对象。而 JavaScript 是一种遵循改标准实现的语言：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ecmascript.gif" alt="ECMAScript 是一种标准" />
        <figcaption>ECMAScript 是一种标准</figcaption>
      </figure>
    </p>
<h3 id="DOM">DOM</h3>
<p>DOM（文档对象模型）是 HTML 和 XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档。HTML 或 XML 页面的每个部分都是一个节点的衍生物。请考虑下面的 HTML 页面：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码可以用 DOM 绘制成一个节点层次图：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_domtree.gif" alt="节点层次图" />
        <figcaption>节点层次图</figcaption>
      </figure>
    </p>
<p>DOM 通过创建树来表示文档，从而使开发者对文档的内容和结构具有空前的控制力。用 DOM API 可以轻松地删除、添加和替换节点。</p>
<h3 id="BOM">BOM</h3>
<p>IE 3.0 和 Netscape Navigator 3.0 提供了一种特性 - BOM（浏览器对象模型），可以对浏览器窗口进行访问和操作。使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使 BOM 独树一帜且又常常令人怀疑的地方在于，它只是 JavaScript 的一个部分，没有任何相关的标准。</p>
<p>BOM 主要处理浏览器窗口和框架，不过通常浏览器特定的 JavaScript 扩展都被看做 BOM 的一部分。这些扩展包括：</p>
<ul>
<li>弹出新的浏览器窗口</li>
<li>移动、关闭浏览器窗口以及调整窗口大小</li>
<li>提供 Web 浏览器详细信息的定位对象</li>
<li>提供用户屏幕分辨率详细信息的屏幕对象</li>
<li>对 cookie 的支持</li>
</ul>
<p>IE 扩展了 BOM，加入了 ActiveXObject 类，可以通过 JavaScript 实例化 ActiveX 对象
由于没有相关的 BOM 标准，每种浏览器都有自己的 BOM 实现。有一些事实上的标准，如具有一个窗口对象和一个导航对象，不过每种浏览器可以为这些对象或其他对象定义自己的属性和方法。</p>
<h2 id="ES3-基础">ES3 基础</h2>
<h3 id="基础">基础</h3>
<h4 id="区分大小写">区分大小写</h4>
<p>比如变量 <code>test</code> 与变量 <code>TEST</code> 是不同的。</p>
<h4 id="弱类型">弱类型</h4>
<p>与 Java 和 C 不同，ECMAScript 中的变量无特定的类型，定义变量时只用 var 运算符，可以将它初始化为任意值。</p>
<p>因此，可以随时改变变量所存数据的类型（尽量避免这样做）。</p>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> visible = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h4 id="每行结尾的分号可有可无">每行结尾的分号可有可无</h4>
<p>Java、C 和 Perl 都要求每行代码以分号（;）结束才符合语法。</p>
<p>ECMAScript 则允许开发者自行决定是否以分号结束一行代码。如果没有分号，ECMAScript 就把折行代码的结尾看做该语句的结尾（与 Visual Basic 和 VBScript 相似），前提是这样没有破坏代码的语义。</p>
<p>最好的代码编写习惯是总加入分号，因为没有分号，有些浏览器就不能正确运行，不过根据 ECMAScript 标准，下面两行代码都是正确的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = <span class="string">&quot;red&quot;</span></span><br><span class="line"><span class="keyword">var</span> test2 = <span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="注释">注释</h4>
<p>ECMAScript 借用了 Java 、C 这些语言的注释语法。</p>
<p>有两种类型的注释：</p>
<ul>
<li>单行注释以双斜杠开头（//）</li>
<li>多行注释以单斜杠和星号开头（/<em>），以星号和单斜杠结尾（</em>/）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this is a single-line comment</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*this is a multi-</span></span><br><span class="line"><span class="comment">line comment*/</span></span><br></pre></td></tr></table></figure>
<h4 id="括号表示代码块">括号表示代码块</h4>
<p>从 Java 中借鉴的另一个概念是代码块。</p>
<p>代码块表示一系列应该按顺序执行的语句，这些语句被封装在左括号（{）和右括号（}）之间。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (test1 == <span class="string">&quot;red&quot;</span>) &#123;</span><br><span class="line">    test1 = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">    alert(test1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="变量">变量</h3>
<p>请使用 var 运算符声明变量。变量名需要遵守一些简单的规则。</p>
<h4 id="声明变量">声明变量</h4>
<p>在上一节中我们讲解过，ECMAScript 中的变量是用 var 运算符（variable 的缩写）加变量名定义的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;hi&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，声明了变量 test，并把它的值初始化为 “hi”（字符串）。由于 ECMAScript 是弱类型的，所以解释程序会为 test 自动创建一个字符串值，无需明确的类型声明。</p>
<p>还可以用一个 var 语句定义两个或多个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test1 = <span class="string">&quot;hi&quot;</span>, test2 = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>不过<strong>用同一个 var 语句定义的变量不必具有相同的类型</strong>，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;hi&quot;</span>, age = <span class="number">25</span>;</span><br></pre></td></tr></table></figure>
<p>这个例子除了（再次）定义 test 外，还定义了 age，并把它初始化为 25。即使 test 和 age 属于两种不同的数据类型，在 ECMAScript 中这样定义也是完全合法的。</p>
<p>与 Java 不同，ECMAScript 中的变量并不一定要初始化。因此，下面这一行代码也是有效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sTest = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">sTest2 = sTest + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">alert(sTest2);</span><br></pre></td></tr></table></figure>
<p>此外，与 Java 不同的还有变量可以存放不同类型的值。这是弱类型变量的优势。例如，可以把变量初始化为字符串类型的值，之后把它设置为数字值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line">alert(test);</span><br><span class="line">test = <span class="number">55</span>;</span><br><span class="line">alert(test);</span><br></pre></td></tr></table></figure>
<p>这段代码将毫无问题地输出字符串值和数字值。但是，如前所述，使用变量时，好的编码习惯是始终存放相同类型的值。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  要让JavaScript支持强类型，可以参考 <a href="/wiki/javascript-tools.html#%E5%BC%BA%E7%B1%BB%E5%9E%8B">工具栈-强类型</a>
</div>
<h4 id="命名变量">命名变量</h4>
<p>变量名需要遵守两条简单的规则：</p>
<ol>
<li>第一个字符必须是字母、下划线（<code>_</code>）或美元符号（<code>$</code>）</li>
<li>余下的字符可以是下划线、美元符号或任何字母或数字字符</li>
</ol>
<p>下面的变量都是合法的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test;</span><br><span class="line"><span class="keyword">var</span> $test;</span><br><span class="line"><span class="keyword">var</span> $<span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> _$te$t2;</span><br></pre></td></tr></table></figure>
<p>W3CSchool 用的是匈牙利类型标记法命名，在 Pascal 标记法命名的变量前附加一个小写字母（或小写字母序列），说明该变量的类型。例如，i 表示整数，s 表示字符串，如下所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>前缀</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>a</td>
<td>aValues</td>
</tr>
<tr>
<td>布尔型</td>
<td>b</td>
<td>bFound</td>
</tr>
<tr>
<td>浮点型（数字）</td>
<td>f</td>
<td>fValue</td>
</tr>
<tr>
<td>函数</td>
<td>fn</td>
<td>fnMethod</td>
</tr>
<tr>
<td>整型（数字）</td>
<td>i</td>
<td>iValue</td>
</tr>
<tr>
<td>对象</td>
<td>o</td>
<td>oType</td>
</tr>
<tr>
<td>正则表达式</td>
<td>re</td>
<td>rePattern</td>
</tr>
<tr>
<td>字符串</td>
<td>s</td>
<td>sValue</td>
</tr>
<tr>
<td>变型（可以是任何类型）</td>
<td>v</td>
<td>vValue</td>
</tr>
</tbody>
</table>
<h3 id="关键字">关键字</h3>
<p>参见 <a href="/wiki/javascript-tables.html#ecmascript-%E5%85%B3%E9%94%AE%E5%AD%97">速查表 - ECMAScript 关键字</a></p>
<h3 id="保留字">保留字</h3>
<p>参见 <a href="/wiki/javascript-tables.html#ecmascript-%E4%BF%9D%E7%95%99%E5%AD%97">速查表 - ECMAScript 保留字</a></p>
<h3 id="原始值和引用值">原始值和引用值</h3>
<p>在 ECMAScript 中，变量可以存在两种类型的值，即原始值和引用值。</p>
<ul>
<li><strong>原始值</strong> - 存储在栈（stack）中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。</li>
<li><strong>引用值</strong> - 存储在堆（heap）中的对象，也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。</li>
</ul>
<p>为变量赋值时，ECMAScript 的解释程序必须判断该值是原始类型，还是引用类型。要实现这一点，解释程序则需<strong>尝试判断该值是否为 ECMAScript 的原始类型之一</strong>，即 Undefined、Null、Boolean、Number 和 String 型。由于这些原始类型占据的空间是固定的，所以可将他们存储在较小的内存区域 - 栈中。这样存储便于迅速查寻变量的值。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  在许多语言中，字符串都被看作引用类型，而非原始类型，因为字符串的长度是可变的。ECMAScript 打破了这一传统。
</div>
<p>如果一个值是引用类型的，那么它的存储空间将从堆中分配。由于引用值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响。如下图所示：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_value.gif" alt="" />
        <figcaption></figcaption>
      </figure>
    </p>
<h2 id="原始类型">原始类型</h2>
<p>ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String。</p>
<h3 id="typeof-运算符">typeof 运算符</h3>
<p>typeof 运算符有一个参数，即要检查的变量或值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sTemp = <span class="string">&quot;test string&quot;</span>;</span><br><span class="line">alert (<span class="keyword">typeof</span> sTemp);    <span class="comment">//输出 &quot;string&quot;</span></span><br><span class="line">alert (<span class="keyword">typeof</span> <span class="number">86</span>);    <span class="comment">//输出 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>
<p>对变量或值调用 typeof 运算符将返回下列值之一：</p>
<ul>
<li>undefined - 如果变量是 Undefined 类型的</li>
<li>boolean - 如果变量是 Boolean 类型的</li>
<li>number - 如果变量是 Number 类型的</li>
<li>string - 如果变量是 String 类型的</li>
<li>object - 如果变量是一种引用类型或 Null 类型的</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：您也许会问，为什么 typeof 运算符对于 null 值会返回 “Object”。这实际上是 JavaScript 最初实现中的一个错误，然后被 ECMAScript 沿用了。现在，null 被认为是对象的占位符，从而解释了这一矛盾，但从技术上来说，它仍然是原始值。
</div>
<h3 id="Undefined-类型">Undefined 类型</h3>
<p>如前所述，Undefined 类型只有一个值，即 undefined。当声明的变量未初始化时，该变量的默认值是 undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br></pre></td></tr></table></figure>
<p>前面一行代码声明变量 oTemp，没有初始值。该变量将被赋予值 undefined，即 undefined 类型的字面量。可以用下面的代码段测试该变量的值是否等于 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br><span class="line">alert(oTemp == <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>这段代码将显示 “true”，说明这两个值确实相等。还可以用 typeof 运算符显示该变量的值是 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br><span class="line">alert(<span class="keyword">typeof</span> oTemp); <span class="comment">//输出 &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：值 undefined 并不同于未定义的值。但是，typeof 运算符并不真正区分这两种值。考虑下面的代码：
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> oTemp);  <span class="comment">//输出 &quot;undefined&quot;</span></span><br><span class="line">alert(<span class="keyword">typeof</span> oTemp2);  <span class="comment">//输出 &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>前面的代码对两个变量输出的都是 “undefined”，即使只有变量 oTemp2 从未被声明过。如果对 oTemp2 使用除 typeof 之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。</p>
<p>例如，下面的代码将引发错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oTemp;</span><br><span class="line">alert(oTemp2 == <span class="literal">undefined</span>);</span><br></pre></td></tr></table></figure>
<p>当函数无明确返回值时，返回的也是值 “undefined”，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(testFunc() == <span class="literal">undefined</span>);  <span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="Null-类型">Null 类型</h3>
<p>另一种只有一个值的类型是 Null，它只有一个专用值 null，即它的字面量。值 undefined 实际上是从值 null 派生来的，因此 ECMAScript 把它们定义为相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">null</span> == <span class="literal">undefined</span>);  <span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>尽管这两个值相等，但它们的含义不同。undefined 是声明了变量但未对其初始化时赋予该变量的值，null 则用于表示尚未存在的对象（在讨论 typeof 运算符时，简单地介绍过这一点）。如果函数或方法要返回的是对象，那么找不到该对象时，返回的通常是 null。</p>
<h3 id="Boolean-类型">Boolean 类型</h3>
<p>Boolean 类型是 ECMAScript 中最常用的类型之一。它有两个值 true 和 false （即两个 Boolean 字面量）。</p>
<p>即使 false 不等于 0，0 也可以在必要时被转换成 false，这样在 Boolean 语句中使用两者都是安全的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFound = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bLost = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Number-类型">Number 类型</h3>
<p>ECMA-262 中定义的最特殊的类型是 Number 类型。这种类型既可以表示 32 位的整数，还可以表示 64 位的浮点数。</p>
<p>直接输入的（而不是从另一个变量访问的）任何数字都被看做 Number 类型的字面量。例如，下面的代码声明了存放整数值的变量，它的值由字面量 86 定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">86</span>;</span><br></pre></td></tr></table></figure>
<h4 id="八进制数和十六进制数">八进制数和十六进制数</h4>
<p>整数也可以被表示为八进制（以 8 为底）或十六进制（以 16 为底）的字面量。八进制字面量的首数字必须是 0，其后的数字可以是任何八进制数字（0-7），如下面的代码所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">070</span>;  <span class="comment">//070 等于十进制的 56</span></span><br></pre></td></tr></table></figure>
<p>要创建十六进制的字面量，首位数字必须为 0，后面接字母 x，然后是任意的十六进制数字（0 到 9 和 A 到 F）。这些字母可以是大写的，也可以是小写的。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">0x1f</span>;  <span class="comment">//0x1f 等于十进制的 31</span></span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">0xAB</span>;  <span class="comment">//0xAB 等于十进制的 171</span></span><br></pre></td></tr></table></figure>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：尽管所有整数都可以表示为八进制或十六进制的字面量，但所有数学运算返回的都是十进制结果。
</div>
<h4 id="浮点数">浮点数</h4>
<p>要定义浮点值，必须包括小数点和小数点后的一位数字（例如，用 1.0 而不是 1）。这被看作浮点数字面量。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fNum = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>对于浮点字面量的有趣之处在于，用它进行计算前，真正存储的是字符串</strong>。</p>
<h4 id="科学计数法">科学计数法</h4>
<p>对于非常大或非常小的数，可以用科学计数法表示浮点数，可以把一个数表示为数字（包括十进制数字）加 e（或 E），后面加乘以 10 的倍数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fNum = <span class="number">5.618e7</span></span><br></pre></td></tr></table></figure>
<p>该符号表示的是数 56180000。把科学计数法转化成计算式就可以得到该值：5.618 x 107。</p>
<p>也可以用科学计数法表示非常小的数，例如 0.00000000000000008 可以表示为 8-e17（这里，10 被升到 -17 次冥，意味着需要被 10 除 17 次）。ECMAScript 默认把具有 6 个或 6 个以上前导 0 的浮点数转换成科学计数法。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：也可用 64 位 IEEE 754 形式存储浮点值，这意味着十进制值最多可以有 17 个十进制位。17 位之后的值将被裁去，从而造成一些小的数学误差。
</div>
<h4 id="特殊的-Number-值">特殊的 Number 值</h4>
<p>几个特殊值也被定义为 Number 类型。前两个是 <code>Number.MAX_VALUE</code> 和 <code>Number.MIN_VALUE</code>，它们定义了 Number 值集合的外边界。所有 ECMAScript 数都必须在这两个值之间。不过计算生成的数值结果可以不落在这两个值之间。</p>
<p>当计算生成的数大于 <code>Number.MAX_VALUE</code> 时，它将被赋予值 <code>Number.POSITIVE_INFINITY</code>，意味着不再有数字值。同样，生成的数值小于 <code>Number.MIN_VALUE</code> 的计算也会被赋予值 <code>Number.NEGATIVE_INFINITY</code>，也意味着不再有数字值。如果计算返回的是无穷大值，那么生成的结果不能再用于其他计算。</p>
<p>事实上，有专门的值表示无穷大，（如你猜到的）即 Infinity。<code>Number.POSITIVE_INFINITY</code> 的值为 <code>Infinity</code>。<code>Number.NEGATIVE_INFINITY</code> 的值为 <code>-Infinity</code>。</p>
<p>由于无穷大数可以是正数也可以是负数，所以可用一个方法判断一个数是否是有穷的（而不是单独测试每个无穷数）。可以对任何数调用 isFinite() 方法，以确保该数不是无穷大。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = iNum * some_really_large_number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isFinite</span>(iResult)) &#123;</span><br><span class="line">    alert(<span class="string">&quot;finite&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;infinite&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个特殊值是 <code>NaN</code> ，表示非数（Not a Number）。<code>NaN</code> 是个奇怪的特殊值。一般说来，这种情况发生在类型（String、Boolean 等）转换失败时。例如，要把单词 blue 转换成数值就会失败，因为没有与之等价的数值。与无穷大一样，<code>NaN</code> 也不能用于算术计算。<code>NaN</code> 的另一个奇特之处在于，它与自身不相等，这意味着下面的代码将返回 false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="literal">NaN</span> == <span class="literal">NaN</span>);  <span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<p>出于这个原因，不推荐使用 NaN 值本身。函数 <code>isNaN()</code> 会做得相当好：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;blue&quot;</span>));  <span class="comment">//输出 &quot;true&quot;</span></span><br><span class="line">alert(<span class="built_in">isNaN</span>(<span class="string">&quot;666&quot;</span>));  <span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="String-类型">String 类型</h3>
<p>String 类型的独特之处在于，它是唯一没有固定大小的原始类型。可以用字符串存储 0 或更多的 Unicode 字符，有 16 位整数表示（Unicode 是一种国际字符集，本教程后面将讨论它）。</p>
<p>字符串中每个字符都有特定的位置，首字符从位置 0 开始，第二个字符在位置 1，依此类推。这意味着字符串中的最后一个字符的位置一定是字符串的长度减 1：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_string.gif" alt="字符串的长度和字符的位置" />
        <figcaption>字符串的长度和字符的位置</figcaption>
      </figure>
    </p>
<p>字符串字面量是由双引号（<code>&quot;</code>）或单引号（<code>'</code>）声明的。而 Java 则是用双引号声明字符串，用单引号声明字符。但是由于 ECMAScript 没有字符类型，所以可使用这两种表示法中的任何一种。例如，下面的两行代码都有效：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sColor1 = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> sColor2 = <span class="string">&#x27;red&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>String 类型还包括几种<a href="/wiki/javascript-tables.html#ecmascript-%E5%AD%97%E7%AC%A6%E5%AD%97%E9%9D%A2%E9%87%8F">字符字面量</a>，Java、C 和 Perl 的开发者应该对此非常熟悉。</p>
<h3 id="类型转换">类型转换</h3>
<p>ECMAScript 给开发者提供了大量简单的类型转换方法。</p>
<h4 id="转换成字符串">转换成字符串</h4>
<p>3 种主要的原始类型 Boolean 值、数字和字符串都有 <code>toString()</code> 方法，可以把它们的值转换成字符串。</p>
<p>Boolean 类型的 <code>toString()</code> 方法只是输出 “true” 或 “false”，结果由变量的值决定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFound = <span class="literal">false</span>;</span><br><span class="line">alert(bFound.toString());	<span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<p>Number 类型的 <code>toString()</code> 方法比较特殊，它有两种模式，即默认模式和基模式。采用默认模式，toString() 方法只是用相应的字符串输出数字值（无论是整数、浮点数还是科学计数法），如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">10.0</span>;</span><br><span class="line">alert(iNum1.toString());	<span class="comment">//输出 &quot;10&quot;</span></span><br><span class="line">alert(iNum2.toString());	<span class="comment">//输出 &quot;10&quot;</span></span><br></pre></td></tr></table></figure>
<p>注释：在默认模式中，无论最初采用什么表示法声明数字，Number 类型的 <code>toString()</code> 方法返回的都是数字的十进制表示。因此，以八进制或十六进制字面量形式声明的数字输出的都是十进制形式的。</p>
<p>采用 Number 类型的 <code>toString()</code> 方法的基模式，可以用不同的基输出数字，例如二进制的基是 2，八进制的基是 8，十六进制的基是 16。</p>
<p>基只是要转换成的基数的另一种加法而已，它是 <code>toString()</code> 方法的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">alert(iNum.toString(<span class="number">2</span>));	<span class="comment">//输出 &quot;1010&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">8</span>));	<span class="comment">//输出 &quot;12&quot;</span></span><br><span class="line">alert(iNum.toString(<span class="number">16</span>));	<span class="comment">//输出 &quot;A&quot;</span></span><br></pre></td></tr></table></figure>
<p>在前面的示例中，以 3 种不同的形式输出了数字 10，即二进制形式、八进制形式和十六进制形式。HTML 采用十六进制表示每种颜色，在 HTML 中处理数字时这种功能非常有用。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：对数字调用 <code>toString(10)</code> 与调用 <code>toString()</code> 相同，它们返回的都是该数字的十进制形式。
</div>
<h4 id="转换成数字">转换成数字</h4>
<p>ECMAScript 提供了两种把非数字的原始值转换成数字的方法，即 <code>parseInt()</code> 和 <code>parseFloat()</code> 。</p>
<p>正如您可能想到的，前者把值转换成整数，后者把值转换成浮点数。只有对 String 类型调用这些方法，它们才能正确运行；对其他类型返回的都是 NaN。</p>
<h5 id="parseInt">parseInt()</h5>
<p>在判断字符串是否是数字值前，<code>parseInt()</code> 和 <code>parseFloat()</code> 都会仔细分析该字符串。</p>
<p>parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。这一过程将持续到发现非有效数字的字符为止，此时 <code>parseInt()</code> 将把该字符之前的字符串转换成数字。</p>
<p>例如，如果要把字符串 “12345red” 转换成整数，那么 <code>parseInt()</code> 将返回 12345，因为当它检查到字符 r 时，就会停止检测过程。</p>
<p>字符串中包含的数字字面量会被正确转换为数字，比如 “0xA” 会被正确转换为数字 10。不过，字符串 “22.5” 将被转换成 22，因为对于整数来说，小数点是无效字符。</p>
<p>一些示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;12345red&quot;</span>);	<span class="comment">//返回 12345</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;0xA&quot;</span>);	<span class="comment">//返回 10</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;56.9&quot;</span>);	<span class="comment">//返回 56</span></span><br><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;red&quot;</span>);	<span class="comment">//返回 NaN</span></span><br></pre></td></tr></table></figure>
<p><code>parseInt()</code> 方法还有基模式，可以把二进制、八进制、十六进制或其他任何进制的字符串转换成整数。基是由 <code>parseInt()</code> 方法的第二个参数指定的，所以要解析十六进制的值，需如下调用 <code>parseInt()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;AF&quot;</span>, <span class="number">16</span>);	<span class="comment">//返回 175</span></span><br></pre></td></tr></table></figure>
<p>当然，对二进制、八进制甚至十进制（默认模式），都可以这样调用 <code>parseInt()</code> 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">2</span>);	<span class="comment">//返回 2</span></span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">8</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum3 = <span class="built_in">parseInt</span>(<span class="string">&quot;10&quot;</span>, <span class="number">10</span>);	<span class="comment">//返回 10</span></span><br></pre></td></tr></table></figure>
<p>如果十进制数包含前导 0，那么最好采用基数 10，这样才不会意外地得到八进制的值。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>, <span class="number">8</span>);	<span class="comment">//返回 8</span></span><br><span class="line"><span class="keyword">var</span> iNum3 = <span class="built_in">parseInt</span>(<span class="string">&quot;010&quot;</span>, <span class="number">10</span>);	<span class="comment">//返回 10</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，两行代码都把字符 “010” 解析成一个数字。第一行代码把这个字符串看作八进制的值，解析它的方式与第二行代码（声明基数为 8）相同。最后一行代码声明基数为 10，所以 iNum3 最后等于 10。</p>
<h5 id="parseFloat">parseFloat()</h5>
<p><code>parseFloat()</code> 方法与 <code>parseInt()</code> 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。</p>
<p>不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。<code>parseFloat()</code> 会把这个小数点之前的字符转换成数字。这意味着字符串 “11.22.33” 将被解析成 11.22。</p>
<p>使用 <code>parseFloat()</code> 方法的另一不同之处在于，字符串必须以十进制形式表示浮点数，而不是用八进制或十六进制。该方法会忽略前导 0，所以八进制数 0102 将被解析为 102。对于十六进制数 0xA，该方法将返回 NaN，因为在浮点数中，x 不是有效字符。（注释：经测试，具体的浏览器实现会返回 0，而不是 NaN。）</p>
<p>此外，<code>parseFloat()</code> 方法也没有基模式。</p>
<p>下面是使用 <code>parseFloat()</code> 方法的一些示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fNum1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;12345red&quot;</span>);	<span class="comment">//返回 12345</span></span><br><span class="line"><span class="keyword">var</span> fNum2 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0xA&quot;</span>);	<span class="comment">//返回 NaN</span></span><br><span class="line"><span class="keyword">var</span> fNum3 = <span class="built_in">parseFloat</span>(<span class="string">&quot;11.2&quot;</span>);	<span class="comment">//返回 11.2</span></span><br><span class="line"><span class="keyword">var</span> fNum4 = <span class="built_in">parseFloat</span>(<span class="string">&quot;11.22.33&quot;</span>);	<span class="comment">//返回 11.22</span></span><br><span class="line"><span class="keyword">var</span> fNum5 = <span class="built_in">parseFloat</span>(<span class="string">&quot;0102&quot;</span>);	<span class="comment">//返回 102</span></span><br><span class="line"><span class="keyword">var</span> fNum1 = <span class="built_in">parseFloat</span>(<span class="string">&quot;red&quot;</span>);	<span class="comment">//返回 NaN</span></span><br></pre></td></tr></table></figure>
<h4 id="强制类型转换">强制类型转换</h4>
<p>您还可以使用强制类型转换（type casting）来处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。</p>
<p>ECMAScript 中可用的 3 种强制类型转换如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(value) - 把给定的值转换成 <span class="built_in">Boolean</span> 型；</span><br><span class="line"><span class="built_in">Number</span>(value) - 把给定的值转换成数字（可以是整数或浮点数）；</span><br><span class="line"><span class="built_in">String</span>(value) - 把给定的值转换成字符串；</span><br></pre></td></tr></table></figure>
<p>用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。</p>
<h5 id="Boolean-函数">Boolean() 函数</h5>
<p>当要转换的值是至少有一个字符的字符串、非 0 数字或对象时，<code>Boolean()</code> 函数将返回 true。如果该值是空字符串、数字 0、undefined 或 null，它将返回 false。</p>
<p>可以用下面的代码测试 Boolean 型的强制类型转换：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="string">&quot;&quot;</span>);		<span class="comment">//false - 空字符串</span></span><br><span class="line"><span class="keyword">var</span> b2 = <span class="built_in">Boolean</span>(<span class="string">&quot;hello&quot;</span>);		<span class="comment">//true - 非空字符串</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">50</span>);		<span class="comment">//true - 非零数字</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="literal">null</span>);		<span class="comment">//false - null</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="number">0</span>);		<span class="comment">//false - 零</span></span><br><span class="line"><span class="keyword">var</span> b1 = <span class="built_in">Boolean</span>(<span class="keyword">new</span> object());	<span class="comment">//true - 对象</span></span><br></pre></td></tr></table></figure>
<h5 id="Number-函数">Number() 函数</h5>
<p><code>Number()</code> 函数的强制类型转换与 <code>parseInt()</code> 和 <code>parseFloat()</code> 方法的处理方式相似，只是它转换的是整个值，而不是部分值。</p>
<p>还记得吗，<code>parseInt()</code> 和 <code>parseFloat()</code> 方法只转换第一个无效字符之前的字符串，因此 “1.2.3” 将分别被转换为 “1” 和 “1.2”。</p>
<p>用 <code>Number()</code> 进行强制类型转换，“1.2.3” 将返回 NaN，因为整个字符串值不能转换成数字。如果字符串值能被完整地转换，<code>Number()</code> 将判断是调用 <code>parseInt()</code> 方法还是 <code>parseFloat()</code> 方法。</p>
<p>下表说明了对不同的值调用 <code>Number()</code> 方法会发生的情况：</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number(false)</td>
<td>0</td>
</tr>
<tr>
<td>Number(true)</td>
<td>1</td>
</tr>
<tr>
<td>Number(undefined)</td>
<td>NaN</td>
</tr>
<tr>
<td>Number(null)</td>
<td>0</td>
</tr>
<tr>
<td>Number(“1.2”)</td>
<td>1.2</td>
</tr>
<tr>
<td>Number(“12”)</td>
<td>12</td>
</tr>
<tr>
<td>Number(“1.2.3”)</td>
<td>NaN</td>
</tr>
<tr>
<td>Number(new object())</td>
<td>NaN</td>
</tr>
<tr>
<td>Number(50)</td>
<td>50</td>
</tr>
</tbody>
</table>
<h5 id="String-函数">String() 函数</h5>
<p>最后一种强制类型转换方法 <code>String()</code> 是最简单的，因为它可把任何值转换成字符串。</p>
<p>要执行这种强制类型转换，只需要调用作为参数传递进来的值的 <code>toString()</code> 方法，即把 12 转换成 “12”，把 true 转换成 “true”，把 false 转换成 “false”，以此类推。</p>
<p>强制转换成字符串和调用 toString() 方法的唯一不同之处在于，对 null 和 undefined 值强制类型转换可以生成字符串而不引发错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">String</span>(<span class="literal">null</span>);	<span class="comment">//&quot;null&quot;</span></span><br><span class="line"><span class="keyword">var</span> oNull = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = oNull.toString();	<span class="comment">//会引发错误</span></span><br></pre></td></tr></table></figure>
<p>在处理 ECMAScript 这样的弱类型语言时，强制类型转换非常有用，不过应该确保使用值的正确。</p>
<h2 id="引用类型">引用类型</h2>
<p>引用类型通常叫做类（class）。也就是说，遇到引用值，所处理的就是对象。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：从传统意义上来说，ECMAScript 并不真正具有类。事实上，除了说明不存在类，在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。
</div>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：本教程将使用术语“对象”。
</div>
<p>对象是由 new 运算符加上要实例化的对象的名字创建的。例如，下面的代码创建 Object 对象的实例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>这种语法与 Java 语言很相似，不过当有不止一个参数时，ECMAScript 要求使用括号。如果没有参数，如以下代码所示，括号可以省略：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br></pre></td></tr></table></figure>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：尽管括号不是必需的，但是为了避免混乱，最好使用括号。
</div>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：我们会在对象基础这一章中更深入地探讨对象及其行为。
</div>
<p>这一节的重点是具有等价的原始类型的引用类型。</p>
<h3 id="Object-对象">Object 对象</h3>
<p>Object 对象自身用处不大，不过在了解其他类之前，还是应该了解它。因为 ECMAScript 中的 Object 对象与 Java 中的 java.lang.Object 相似，ECMAScript 中的所有对象都由这个对象继承而来，Object 对象中的所有属性和方法都会出现在其他对象中，所以理解了 Object 对象，就可以更好地理解其他对象。</p>
<p>Object 对象具有下列属性：</p>
<ul>
<li>constructor - 对创建对象的函数的引用（指针）。对于 Object 对象，该指针指向原始的 Object() 函数。</li>
<li>Prototype - 对该对象的对象原型的引用。对于所有的对象，它默认返回 Object 对象的一个实例。</li>
</ul>
<p>Object 对象还具有几个方法：</p>
<ul>
<li>hasOwnProperty(property) - 判断对象是否有某个特定的属性。必须用字符串指定该属性。（例如，<code>o.hasOwnProperty(&quot;name&quot;)</code>）</li>
<li>IsPrototypeOf(object) - 判断该对象是否为另一个对象的原型。</li>
<li>PropertyIsEnumerable - 判断给定的属性是否可以用 <code>for...in</code> 语句进行枚举。</li>
<li>ToString() - 返回对象的原始字符串表示。对于 Object 对象，ECMA-262 没有定义这个值，所以不同的 ECMAScript 实现具有不同的值。</li>
<li>ValueOf() - 返回最适合该对象的原始值。对于许多对象，该方法返回的值都与 ToString() 的返回值相同。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：上面列出的每种属性和方法都会被其他对象覆盖。
</div>
<h3 id="Boolean-对象">Boolean 对象</h3>
<p>Boolean 对象是 Boolean 原始类型的引用类型。</p>
<p>要创建 Boolean 对象，只需要传递 Boolean 值作为参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oBooleanObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>Boolean 对象将覆盖 Object 对象的 ValueOf() 方法，返回原始值，即 true 和 false。ToString() 方法也会被覆盖，返回字符串 “true” 或 “false”。</p>
<p>遗憾的是，在 ECMAScript 中很少使用 Boolean 对象，即使使用，也不易理解。</p>
<p>问题通常出现在 Boolean 表达式中使用 Boolean 对象时。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oFalseObject = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> bResult = oFalseObject &amp;&amp; <span class="literal">true</span>;	<span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，用 false 值创建 Boolean 对象。然后用这个值与原始值 true 进行 AND 操作。在 Boolean 运算中，false 和 true 进行 AND 操作的结果是 false。不过，在这行代码中，计算的是 oFalseObject，而不是它的值 false。<a href="#toboolean-%E6%93%8D%E4%BD%9C">在 Boolean 表达式中，所有对象都会被自动转换为 true</a>，所以 oFalseObject 的值是 true。然后 true 再与 true 进行 AND 操作，结果为 true。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：虽然你应该了解 Boolean 对象的可用性，不过<strong>最好还是使用 Boolean 原始值</strong>，避免发生这一节提到的问题。
</div>
<h3 id="Number-对象">Number 对象</h3>
<p>正如你可能想到的，Number 对象是 Number 原始类型的引用类型。要创建 Number 对象，采用下列代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br></pre></td></tr></table></figure>
<p>您应该已认出本章前面小节中讨论特殊值（如 <code>Number.MAX_VALUE</code>）时提到的 Number 对象。所有特殊值都是 Number 对象的静态属性。</p>
<p>要得到数字对象的 Number 原始值，只需要使用 valueOf() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNumber = oNumberObject.valueOf();</span><br></pre></td></tr></table></figure>
<p>当然，Number 类也有 <code>toString()</code> 方法，在讨论类型转换的小节中已经详细讨论过该方法。</p>
<p>除了从 Object 对象继承的标准方法外，Number 对象还有几个处理数值的专用方法。</p>
<h4 id="toFixed-方法">toFixed() 方法</h4>
<p>toFixed() 方法返回的是具有指定位数小数的数字的字符串表示。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toFixed(<span class="number">2</span>));  <span class="comment">//输出 &quot;68.00&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，toFixed() 方法的参数是 2，说明应该显示两位小数。该方法返回 “68.00”，空的字符串位由 0 来补充。对于处理货币的应用程序，该方法非常有用。toFixed() 方法能表示具有 0 到 20 位小数的数字，超过这个范围的值会引发错误。</p>
<h4 id="toExponential-方法">toExponential() 方法</h4>
<p>与格式化数字相关的另一个方法是 toExponential()，它返回的是用科学计数法表示的数字的字符串形式。</p>
<p>与 toFixed() 方法相似，toExponential() 方法也有一个参数，指定要输出的小数的位数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toExponential(<span class="number">1</span>));  <span class="comment">//输出 &quot;6.8e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的结果是 “6.8e+1”，前面解释过，它表示 6.8x101。问题是，如果不知道要用哪种形式（预定形式或指数形式）表示数字怎么办？可以用 toPrecision() 方法。</p>
<h4 id="toPrecision-方法">toPrecision() 方法</h4>
<p>toPrecision() 方法根据最有意义的形式来返回数字的预定形式或指数形式。它有一个参数，即用于表示数的数字总数（不包括指数）。例如，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">1</span>));  <span class="comment">//输出 &quot;7e+1&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的任务是用一位数字表示数字 68，结果为 “7e+1”，以另外的形式表示即 70。的确，toPrecision() 方法会对数进行舍入。不过，如果用 2 位数字表示 68，就容易多了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">2</span>));  <span class="comment">//输出 &quot;68&quot;</span></span><br></pre></td></tr></table></figure>
<p>当然，输出的是 “68”，因为这正是该数的准确表示。不过，如果指定的位数多于需要的位数又如何呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oNumberObject = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">68</span>);</span><br><span class="line">alert(oNumberObject.toPrecision(<span class="number">3</span>));  <span class="comment">//输出 &quot;68.0&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，toPrecision(3) 等价于 toFixed(1)，输出的是 “68.0”。</p>
<p>toFixed()、toExponential() 和 toPrecision() 方法都会进行舍入操作，以便用正确的小数位数正确地表示一个数。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：与 Boolean 对象相似，Number 对象也很重要，不过<strong>应该少用这种对象，以避免潜在的问题</strong>。只要可能，都使用数字的原始表示法。
</div>
<h3 id="String-对象">String 对象</h3>
<p>String 对象是 String 原始类型的对象表示法，它是以下方式创建的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">String</span> 对象的 valueOf() 方法和 toString() 方法都会返回 <span class="built_in">String</span> 类型的原始值：</span><br><span class="line">alert(oStringObject.valueOf() == oStringObject.toString());	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>如果运行这段代码，输出是 “true”，说明这些值真的相等。</p>
<h4 id="length-属性">length 属性</h4>
<p>String 对象具有属性 length，它是字符串中的字符个数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.length);	<span class="comment">//输出 &quot;11&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出的是 “11”，即 “hello world” 中的字符个数。注意，即使字符串包含双字节的字符（与 ASCII 字符相对，ASCII 字符只占用一个字节），每个字符也只算一个字符。</p>
<h4 id="charAt-和-charCodeAt-方法">charAt() 和 charCodeAt() 方法</h4>
<p>String 对象还拥有大量的方法。</p>
<p>首先，两个方法 charAt() 和 charCodeAt() 访问的是字符串中的单个字符。这两个方法都有一个参数，即要操作的字符的位置。</p>
<p>charAt() 方法返回的是包含指定位置处的字符的字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.charAt(<span class="number">1</span>));	<span class="comment">//输出 &quot;e&quot;</span></span><br></pre></td></tr></table></figure>
<p>在字符串 “hello world” 中，位置 1 处的字符是 “e”。在“ECMAScript 原始类型”这一节中我们讲过，第一个字符的位置是 0，第二个字符的位置是 1，依此类推。因此，调用 charAt(1) 返回的是 “e”。</p>
<p>如果想得到的不是字符，而是字符代码，那么可以调用 charCodeAt() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.charCodeAt(<span class="number">1</span>));	<span class="comment">//输出 &quot;101&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个例子输出 “101”，即小写字母 “e” 的字符代码。</p>
<h4 id="concat-方法">concat() 方法</h4>
<p>接下来是 concat() 方法，用于把一个或多个字符串连接到 String 对象的原始值上。该方法返回的是 String 原始值，保持原始的 String 对象不变：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sResult = oStringObject.concat(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">alert(sResult);		<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject);	<span class="comment">//输出 &quot;hello &quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，调用 concat() 方法返回的是 “hello world”，而 String 对象存放的仍然是 &quot;hello &quot;。出于这种原因，较常见的是用加号（+）连接字符串，因为这种形式从逻辑上表明了真正的行为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line"><span class="keyword">var</span> sResult = oStringObject + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">alert(sResult);		<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject);	<span class="comment">//输出 &quot;hello &quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="indexOf-和-lastIndexOf-方法">indexOf() 和 lastIndexOf() 方法</h4>
<p>迄今为止，已讨论过连接字符串的方法，访问字符串中的单个字符的方法。不过如果无法确定在某个字符串中是否确实存在一个字符，应该调用什么方法呢？这时，可调用 indexOf() 和 lastIndexOf() 方法。</p>
<p>indexOf() 和 lastIndexOf() 方法返回的都是指定的子串在另一个字符串中的位置，如果没有找不到子串，则返回 -1。</p>
<p>这两个方法的不同之处在于，indexOf() 方法是从字符串的开头（位置 0）开始检索字符串，而 lastIndexOf() 方法则是从字符串的结尾开始检索子串。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">alert(oStringObject.indexOf(<span class="string">&quot;o&quot;</span>));		输出 <span class="string">&quot;4&quot;</span></span><br><span class="line">alert(oStringObject.lastIndexOf(<span class="string">&quot;o&quot;</span>));	输出 <span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，第一个 “o” 字符串出现在位置 4，即 “hello” 中的 “o”；最后一个 “o” 出现在位置 7，即 “world” 中的 “o”。如果该字符串中只有一个 “o” 字符串，那么 indexOf() 和 lastIndexOf() 方法返回的位置相同。</p>
<h4 id="localeCompare-方法">localeCompare() 方法</h4>
<p>下一个方法是 localeCompare()，对字符串进行排序。该方法有一个参数 - 要进行比较的字符串，返回的是下列三个值之一：</p>
<ul>
<li>如果 String 对象按照字母顺序排在参数中的字符串之前，返回负数。</li>
<li>如果 String 对象等于参数中的字符串，返回 0</li>
<li>如果 String 对象按照字母顺序排在参数中的字符串之后，返回正数。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果返回负数，那么最常见的是 -1，不过真正返回的是由实现决定的。如果返回正数，那么同样的，最常见的是 1，不过真正返回的是由实现决定的。
</div>
<p>示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;brick&quot;</span>));		<span class="comment">//输出 &quot;1&quot;</span></span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;yellow&quot;</span>));		<span class="comment">//输出 &quot;0&quot;</span></span><br><span class="line">alert(oStringObject.localeCompare(<span class="string">&quot;zoo&quot;</span>));		<span class="comment">//输出 &quot;-1&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，字符串 “yellow” 与 3 个值进行了对比，即 “brick”、“yellow” 和 “zoo”。由于按照字母顺序排列，“yellow” 位于 “brick” 之后，所以 localeCompare() 返回 1；“yellow” 等于 “yellow”，所以 localeCompare() 返回 0；“zoo” 位于 “yellow” 之后，localeCompare() 返回 -1。再强调一次，由于返回的值是由实现决定的，所以最好以下面的方式调用 localeCompare() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;yellow&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> oStringObject2 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;brick&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iResult = oStringObject1.localeCompare(oStringObject2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(iResult &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  alert(oStringObject1 + <span class="string">&quot; comes before &quot;</span> + oStringObject2);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (iResult &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  alert(oStringObject1 + <span class="string">&quot; comes after &quot;</span> + oStringObject2);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">&quot;The two strings are equal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用这种结构，可以确保这段代码在所有实现中都能正确运行。</p>
<p>localeCompare() 方法的独特之处在于，实现所处的区域（locale，兼指国家/地区和语言）确切说明了这种方法运行的方式。在美国，英语是 ECMAScript 实现的标准语言，localeCompare() 是区分大小写的，大写字母在字母顺序上排在小写字母之后。不过，在其他区域，情况可能并非如此。</p>
<h4 id="slice-和-substring">slice() 和 substring()</h4>
<p>ECMAScript 提供了两种方法从子串创建字符串值，即 slice() 和 substring()。这两种方法返回的都是要处理的字符串的子串，都接受一个或两个参数。第一个参数是要获取的子串的起始位置，第二个参数（如果使用的话）是要获取子串终止前的位置（也就是说，获取终止位置处的字符不包括在返回的值内）。如果省略第二个参数，终止位就默认为字符串的长度。</p>
<p>与 concat() 方法一样，slice() 和 substring() 方法都不改变 String 对象自身的值。它们只返回原始的 String 值，保持 String 对象不变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3&quot;</span>));		<span class="comment">//输出 &quot;lo world&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3&quot;</span>));		<span class="comment">//输出 &quot;lo world&quot;</span></span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;7&quot;</span>));		<span class="comment">//输出 &quot;lo w&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3&quot;</span>, <span class="string">&quot;7&quot;</span>));	<span class="comment">//输出 &quot;lo w&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，slice() 和 substring() 的用法相同，返回值也一样。当只有参数 3 时，两个方法返回的都是 “lo world”，因为 “hello” 中的第二个 “l” 位于位置 3 上。当有两个参数 “3” 和 “7” 时，两个方法返回的值都是 “lo w”（“world” 中的字母 “o” 位于位置 7 上，所以它不包括在结果中）。</p>
<p>为什么有两个功能完全相同的方法呢？事实上，<strong>这两个方法并不完全相同</strong>，不过只在参数为负数时，它们处理参数的方式才稍有不同。</p>
<p>对于负数参数，slice() 方法会用字符串的长度加上参数，substring() 方法则将其作为 0 处理（也就是说将忽略它）。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;-3&quot;</span>));		<span class="comment">//输出 &quot;rld&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;-3&quot;</span>));	<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject.slice(<span class="string">&quot;3, -4&quot;</span>));		<span class="comment">//输出 &quot;lo w&quot;</span></span><br><span class="line">alert(oStringObject.substring(<span class="string">&quot;3, -4&quot;</span>));	<span class="comment">//输出 &quot;hel&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样即可看出 slice() 和 substring() 方法的主要不同。</p>
<p>当只有参数 -3 时，slice() 返回 “rld”，substring() 则返回 “hello world”。这是因为对于字符串 “hello world”，slice(&quot;-3&quot;) 将被转换成 slice(“8”)，而 substring(&quot;-3&quot;) 将被转换成 substring(“0”)。</p>
<p>同样，使用参数 3 和 -4 时，差别也很明显。slice() 将被转换成 slice(3, 7)，与前面的例子相同，返回 “lo w”。而 substring() 方法则将两个参数解释为 substring(3, 0)，实际上即 substring(0, 3)，因为 substring() 总把较小的数字作为起始位，较大的数字作为终止位。因此，substring(“3, -4”) 返回的是 “hel”。这里的最后一行代码用来说明如何使用这些方法。</p>
<h4 id="toLowerCase-、toLocaleLowerCase-、toUpperCase-和-toLocaleUpperCase">toLowerCase()、toLocaleLowerCase()、toUpperCase() 和 toLocaleUpperCase()</h4>
<p>最后一套要讨论的方法涉及大小写转换。有 4 种方法用于执行大小写转换，即</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">toLowerCase()</span><br><span class="line">toLocaleLowerCase()</span><br><span class="line">toUpperCase()</span><br><span class="line">toLocaleUpperCase()</span><br></pre></td></tr></table></figure>
<p>从名字上可以看出它们的用途，前两种方法用于把字符串转换成全小写的，后两种方法用于把字符串转换成全大写的。</p>
<p>toLowerCase() 和 toUpperCase() 方法是原始的，是以 java.lang.String 中相同方法为原型实现的。</p>
<p>toLocaleLowerCase() 和 toLocaleUpperCase() 方法是基于特定的区域实现的（与 localeCompare() 方法相同）。在许多区域中，区域特定的方法都与通用的方法完全相同。不过，有几种语言对 Unicode 大小写转换应用了特定的规则（例如土耳其语），因此必须使用区域特定的方法才能进行正确的转换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">alert(oStringObject.toLocaleUpperCase());	<span class="comment">//输出 &quot;HELLO WORLD&quot;</span></span><br><span class="line">alert(oStringObject.toUpperCase());		<span class="comment">//输出 &quot;HELLO WORLD&quot;</span></span><br><span class="line">alert(oStringObject.toLocaleLowerCase());	<span class="comment">//输出 &quot;hello world&quot;</span></span><br><span class="line">alert(oStringObject.toLowerCase());		<span class="comment">//输出 &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码中，toUpperCase() 和 toLocaleUpperCase() 输出的都是 “HELLO WORLD”，toLowerCase() 和 toLocaleLowerCase() 输出的都是 “hello world”。一般来说，如果不知道在以哪种编码运行一种语言，则使用区域特定的方法比较安全。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：记住，String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象。
</div>
<h3 id="instanceof-运算符">instanceof 运算符</h3>
<p>在使用 typeof 运算符时采用引用类型存储值会出现一个问题，无论引用的是什么类型的对象，它都返回 “object”。ECMAScript 引入了另一个 Java 运算符 instanceof 来解决这个问题。</p>
<p>instanceof 运算符与 typeof 运算符相似，用于识别正在处理的对象的类型。与 typeof 方法不同的是，instanceof 方法要求开发者明确地确认对象为某特定类型。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">alert(oStringObject <span class="keyword">instanceof</span> <span class="built_in">String</span>);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码问的是“变量 oStringObject 是否为 String 对象的实例？”oStringObject 的确是 String 对象的实例，因此结果是 “true”。尽管不像 typeof 方法那样灵活，但是在 typeof 方法返回 “object” 的情况下，instanceof 方法还是很有用的。</p>
<h2 id="运算符">运算符</h2>
<h3 id="一元运算符">一元运算符</h3>
<h4 id="delete">delete</h4>
<p>delete 运算符删除对以前定义的对象属性或方法的引用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">o.name = <span class="string">&quot;David&quot;</span>;</span><br><span class="line">alert(o.name);	<span class="comment">//输出 &quot;David&quot;</span></span><br><span class="line"><span class="keyword">delete</span> o.name;</span><br><span class="line">alert(o.name);	<span class="comment">//输出 &quot;undefined&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，删除了 name 属性，意味着强制解除对它的引用，将其设置为 undefined（即创建的未初始化的变量的值）。</p>
<p>delete 运算符<strong>不能删除开发者未定义的属性和方法</strong>。例如，下面的代码将引发错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> o.toString;</span><br></pre></td></tr></table></figure>
<p>即使 toString 是有效的方法名，这行代码也会引发错误，因为 toString() 方法是原始的 ECMAScript 方法，不是开发者定义的。</p>
<h4 id="void">void</h4>
<p>void 运算符对任何值返回 undefined。该运算符通常用于避免输出不应该输出的值，例如，从 HTML 的 <code>&lt;a&gt;</code> 元素调用 JavaScript 函数时。要正确做到这一点，函数不能返回有效值，否则浏览器将清空页面，只显示函数的结果。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:window.open(&#x27;about:blank&#x27;)&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果把这行代码放入 HTML 页面，点击其中的链接，即可看到屏幕上显示 “[object]”。</p>
<p>这是因为 window.open() 方法返回了新打开的窗口的引用。然后该对象将被转换成要显示的字符串。要避免这种效果，可以用 void 运算符调用 window.open() 函数：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:void(window.open(&#x27;about:blank&#x27;))&quot;</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这使 window.open() 调用返回 undefined，它不是有效值，不会显示在浏览器窗口中。</p>
<p>提示：请记住，没有返回值的函数真正返回的都是 undefined。</p>
<h4 id="前增量-前减量运算符">前增量/前减量运算符</h4>
<p>直接从 C（和 Java）借用的两个运算符是前增量运算符和前减量运算符。所谓前增量运算符，就是数值上加 1，形式是在变量前放两个加号（++）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">++iNum;</span><br></pre></td></tr></table></figure>
<p>第二行代码把 iNum 增加到了 11，它实质上等价于：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum = iNum + <span class="number">1</span>；</span><br></pre></td></tr></table></figure>
<p>同样，前减量运算符是从数值上减 1，形式是在变量前放两个减号（–）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">--iNum;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，第二行代码把 iNum 的值减到 9。</p>
<p>在使用前缀式运算符时，注意增量和减量运算符都发生在计算表达式之前。考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">--iNum;</span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;9&quot;</span></span><br><span class="line">alert(--iNum);	<span class="comment">//输出 &quot;8&quot;</span></span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<p>第二行代码对 iNum 进行减量运算，第三行代码显示的结果是（“9”）。第四行代码又对 iNum 进行减量运算，不过这次前减量运算和输出操作出现在同一个语句中，显示的结果是 “8”。为了证明已实现了所有的减量操作，第五行代码又输出一次&quot;8&quot;。</p>
<p>在算术表达式中，前增量和前减量运算符的优先级是相同的，因此要按照从左到右的顺序计算之。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> iNum3 = --iNum1 + ++iNum2;	<span class="comment">//等于 &quot;22&quot;</span></span><br><span class="line"><span class="keyword">var</span> iNum4 = iNum1 + iNum2;		<span class="comment">//等于 &quot;22&quot;</span></span><br></pre></td></tr></table></figure>
<p>在前面的代码中，iNum3 等于 22，因为表达式要计算的是 1 + 21。变量 iNum4 也等于 22，也是 1 + 21。</p>
<h4 id="后增量-后减量运算符">后增量/后减量运算符</h4>
<p>还有两个直接从 C（和 Java）借用的运算符，即后增量运算符和后减量运算符。后增量运算符也是给数值上加 1，形式是在变量后放两个加号（++）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum++;</span><br></pre></td></tr></table></figure>
<p>不出所料，后减量运算符也是从数值上减 1，形式为在变量后加两个减号（–）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum--;</span><br></pre></td></tr></table></figure>
<p>第二行代码把 iNum 的 值减到 9。与前缀式运算符不同的是，后缀式运算符是在计算过包含它们的表达式后才进行增量或减量运算的。考虑以下的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum--;</span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;9&quot;</span></span><br><span class="line">alert(iNum--);	<span class="comment">//输出 &quot;9&quot;</span></span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;8&quot;</span></span><br></pre></td></tr></table></figure>
<p>与前缀式运算符的例子相似，第二行代码对 iNum 进行减量运算，第三行代码显示结果（“9”）。第四行代码继续显示 iNum 的值，不过这次是在同一语句中应用减量运算符。由于减量运算发生在计算过表达式之后，所以这条语句显示的数是 “9”。执行了第五行代码后，alert 函数显示的是 “8”，因为在执行第四行代码之后和执行第五行代码之前，执行了后减量运算。</p>
<p>在算术表达式中，后增量和后减量运算符的优先级是相同的，因此要按照从左到右的顺序计算之。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> iNum3 = iNum1-- + iNum2++;	<span class="comment">//等于 &quot;22&quot;</span></span><br><span class="line"><span class="keyword">var</span> iNum4 = iNum1 + iNum2;		<span class="comment">//等于 &quot;22&quot;</span></span><br></pre></td></tr></table></figure>
<p>在前面的代码中，iNum3 等于 22，因为表达式要计算的是 2 + 20。变量 iNum4 也等于 22，不过它计算的是 1 + 21，因为增量和减量运算都在给 iNum3 赋值后才发生。</p>
<h4 id="一元加法和一元减法">一元加法和一元减法</h4>
<p>大多数人都熟悉一元加法和一元减法，它们在 ECMAScript 中的用法与您高中数学中学到的用法相同。</p>
<p>一元加法本质上对数字无任何影响：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">20</span>;</span><br><span class="line">iNum = +iNum;</span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;20&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码对数字 20 应用了一元加法，返回的还是 20。尽管一元加法对数字无作用，但对字符串却有有趣的效果，会把字符串转换成数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sNum = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> sNum);	<span class="comment">//输出 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">var</span> iNum = +sNum;</span><br><span class="line">alert(<span class="keyword">typeof</span> iNum);	<span class="comment">//输出 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码把字符串 “20” 转换成真正的数字。当一元加法运算符对字符串进行操作时，它计算字符串的方式与 parseInt() 相似，主要的不同是只有对以 “0x” 开头的字符串（表示十六进制数字），一元运算符才能把它转换成十进制的值。因此，用一元加法转换 “010”，得到的总是 10，而 “0xB” 将被转换成 11。</p>
<p>另一方面，一元减法就是对数值求负（例如把 20 转换成 -20）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">20</span>;</span><br><span class="line">iNum = -iNum;</span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;-20&quot;</span></span><br></pre></td></tr></table></figure>
<p>与一元加法运算符相似，一元减法运算符也会把字符串转换成近似的数字，此外还会对该值求负。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sNum = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">alert(<span class="keyword">typeof</span> sNum);	<span class="comment">//输出 &quot;string&quot;</span></span><br><span class="line"><span class="keyword">var</span> iNum = -sNum;</span><br><span class="line">alert(iNum);		<span class="comment">//输出 &quot;-20&quot;</span></span><br><span class="line">alert(<span class="keyword">typeof</span> iNum);	<span class="comment">//输出 &quot;number&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，一元减法运算符将把字符串 “-20” 转换成 -20（一元减法运算符对十六进制和十进制的处理方式与一元加法运算符相似，只是它还会对该值求负）。</p>
<h3 id="位运算符">位运算符</h3>
<h4 id="位运算-NOT">位运算 NOT</h4>
<p>位运算 NOT 由否定号（~）表示，它是 ECMAScript 中为数不多的与二进制算术有关的运算符之一。</p>
<p>位运算 NOT 是三步的处理过程：</p>
<ol>
<li>把运算数转换成 32 位数字</li>
<li>把二进制数转换成它的二进制反码</li>
<li>把二进制数转换成浮点数</li>
</ol>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">25</span>;		<span class="comment">//25 等于 00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">var</span> iNum2 = ~iNum1;	<span class="comment">//转换为 11111111111111111111111111100110</span></span><br><span class="line">alert(iNum2);		<span class="comment">//输出 &quot;-26&quot;</span></span><br></pre></td></tr></table></figure>
<p>位运算 NOT 实质上是对数字求负，然后减 1，因此 25 变 -26。用下面的方法也可以得到同样的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">var</span> iNum2 = -iNum1 -<span class="number">1</span>;</span><br><span class="line">alert(iNum2);	<span class="comment">//输出 -26</span></span><br></pre></td></tr></table></figure>
<h4 id="位运算-AND">位运算 AND</h4>
<p>位运算 AND 由和号（&amp;）表示，直接对数字的二进制形式进行运算。它把每个数字中的数位对齐，然后用下面的规则对同一位置上的两个数位进行 AND 运算：</p>
<table>
<thead>
<tr>
<th>第一个数字中的数位</th>
<th>第二个数字中的数位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>例如，要对数字 25 和 3 进行 AND 运算，代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">25</span> &amp; <span class="number">3</span>;</span><br><span class="line">alert(iResult);	<span class="comment">//输出 &quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<p>25 和 3 进行 AND 运算的结果是 1。为什么？分析如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line">  3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line">---------------------------------------------</span><br><span class="line">AND &#x3D; 0000 0000 0000 0000 0000 0000 0000 0001</span><br></pre></td></tr></table></figure>
<p>可以看出，在 25 和 3 中，只有一个数位（位 0）存放的都是 1，因此，其他数位生成的都是 0，所以结果为 1。</p>
<h4 id="位运算-OR">位运算 OR</h4>
<p>位运算 OR 由符号（|）表示，也是直接对数字的二进制形式进行运算。在计算每位时，OR 运算符采用下列规则：</p>
<table>
<thead>
<tr>
<th>第一个数字中的数位</th>
<th>第二个数字中的数位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>仍然使用 AND 运算符所用的例子，对 25 和 3 进行 OR 运算，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">25</span> | <span class="number">3</span>;</span><br><span class="line">alert(iResult);	<span class="comment">//输出 &quot;27&quot;</span></span><br></pre></td></tr></table></figure>
<p>25 和 3 进行 OR 运算的结果是 27：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line"> 3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line">--------------------------------------------</span><br><span class="line">OR &#x3D; 0000 0000 0000 0000 0000 0000 0001 1011</span><br></pre></td></tr></table></figure>
<p>可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11011 等于 27。</p>
<h4 id="位运算-XOR">位运算 XOR</h4>
<p>位运算 XOR 由符号（^）表示，当然，也是直接对二进制形式进行运算。XOR 不同于 OR，当只有一个数位存放的是 1 时，它才返回 1。真值表如下：</p>
<table>
<thead>
<tr>
<th>第一个数字中的数位</th>
<th>第二个数字中的数位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>对 25 和 3 进行 XOR 运算，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">25</span> ^ <span class="number">3</span>;</span><br><span class="line">alert(iResult);	<span class="comment">//输出 &quot;26&quot;</span></span><br></pre></td></tr></table></figure>
<p>25 和 3 进行 XOR 运算的结果是 26：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 25 &#x3D; 0000 0000 0000 0000 0000 0000 0001 1001</span><br><span class="line">  3 &#x3D; 0000 0000 0000 0000 0000 0000 0000 0011</span><br><span class="line">---------------------------------------------</span><br><span class="line">XOR &#x3D; 0000 0000 0000 0000 0000 0000 0001 1010</span><br></pre></td></tr></table></figure>
<p>可以看出，在两个数字中，共有 4 个数位存放的是 1，这些数位被传递给结果。二进制代码 11010 等于 26。</p>
<h4 id="左移运算">左移运算</h4>
<p>左移运算由两个小于号表示（&lt;&lt;）。它把数字中的所有数位向左移动指定的数量。例如，把数字 2（等于二进制中的 10）左移 5 位，结果为 64（等于二进制中的 1000000）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iOld = <span class="number">2</span>;		<span class="comment">//等于二进制 10</span></span><br><span class="line"><span class="keyword">var</span> iNew = iOld &lt;&lt; <span class="number">5</span>;	<span class="comment">//等于二进制 1000000 十进制 64</span></span><br></pre></td></tr></table></figure>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注意：在左移数位时，数字右边多出 5 个空位。左移运算用 0 填充这些空位，使结果成为完整的 32 位数字。
</div>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_operators_bitwise_leftshift.gif" alt="数字 2 进行左移运算" />
        <figcaption>数字 2 进行左移运算</figcaption>
      </figure>
    </p>
<p>注意：左移运算保留数字的符号位。例如，如果把 -2 左移 5 位，得到的是 -64，而不是 64。“符号仍然存储在第 32 位中吗？”是的，不过这在 ECMAScript 后台进行，开发者不能直接访问第 32 个数位。即使输出二进制字符串形式的负数，显示的也是负号形式（例如，-2 将显示 -10。）</p>
<h4 id="有符号右移运算">有符号右移运算</h4>
<p>有符号右移运算符由两个大于号表示（&gt;&gt;）。它把 32 位数字中的所有数位整体右移，同时保留该数的符号（正号或负号）。有符号右移运算符恰好与左移运算相反。例如，把 64 右移 5 位，将变为 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iOld = <span class="number">64</span>;		<span class="comment">//等于二进制 1000000</span></span><br><span class="line"><span class="keyword">var</span> iNew = iOld &gt;&gt; <span class="number">5</span>;	<span class="comment">//等于二进制 10 十进制 2</span></span><br></pre></td></tr></table></figure>
<p>同样，移动数位后会造成空位。这次，空位位于数字的左侧，但位于符号位之后。ECMAScript 用符号位的值填充这些空位，创建完整的数字，如下图所示：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_operators_bitwise_signedrightshift.gif" alt="数字 64 进行有符号右移运算" />
        <figcaption>数字 64 进行有符号右移运算</figcaption>
      </figure>
    </p>
<h4 id="无符号右移运算">无符号右移运算</h4>
<p>无符号右移运算符由三个大于号（&gt;&gt;&gt;）表示，它将无符号 32 位数的所有数位整体右移。对于正数，无符号右移运算的结果与有符号右移运算一样。</p>
<p>用有符号右移运算中的例子，把 64 右移 5 位，将变为 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iOld = <span class="number">64</span>;		<span class="comment">//等于二进制 1000000</span></span><br><span class="line"><span class="keyword">var</span> iNew = iOld &gt;&gt;&gt; <span class="number">5</span>;	<span class="comment">//等于二进制 10 十进制 2</span></span><br></pre></td></tr></table></figure>
<p>对于负数，情况就不同了。</p>
<p>无符号右移运算用 0 填充所有空位。对于正数，这与有符号右移运算的操作一样，而负数则被作为正数来处理。</p>
<p>由于无符号右移运算的结果是一个 32 位的正数，所以负数的无符号右移运算得到的总是一个非常大的数字。例如，如果把 -64 右移 5 位，将得到 134217726。如何得到这种结果的呢？</p>
<p>要实现这一点，需要把这个数字转换成无符号的等价形式（尽管该数字本身还是有符号的），可以通过以下代码获得这种形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iUnsigned64 = -<span class="number">64</span> &gt;&gt;&gt; <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>然后，用 Number 类型的 toString() 获取它的真正的位表示，采用的基为 2：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(iUnsigned64.toString(<span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<p>这将生成 11111111111111111111111111000000，即有符号整数 -64 的二进制补码表示，不过它等于无符号整数 4294967232。</p>
<p>出于这种原因，使用无符号右移运算符要小心。</p>
<h3 id="逻辑运算符">逻辑运算符</h3>
<p>逻辑运算符有三种：NOT、AND 和 OR。</p>
<h4 id="ToBoolean-操作">ToBoolean 操作</h4>
<p>在学习各种逻辑运算符之前，让我们先了解一下 ECMAScript-262 v5 规范中描述的 ToBoolean 操作。</p>
<p>抽象操作 ToBoolean 将其参数按照下表中的规则转换为逻辑值：</p>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Undefined</td>
<td>false</td>
</tr>
<tr>
<td>Null</td>
<td>false</td>
</tr>
<tr>
<td>Boolean</td>
<td>结果等于输入的参数（不转换）</td>
</tr>
<tr>
<td>Number</td>
<td>如果参数为 +0, -0 或 NaN，则结果为 false；否则为 true。</td>
</tr>
<tr>
<td>String</td>
<td>如果参数为空字符串，则结果为 false；否则为 true。</td>
</tr>
<tr>
<td>Object</td>
<td>true</td>
</tr>
</tbody>
</table>
<h4 id="逻辑-NOT-运算符">逻辑 NOT 运算符</h4>
<p>在 ECMAScript 中，逻辑 NOT 运算符与 C 和 Java 中的逻辑 NOT 运算符相同，都由感叹号（!）表示。</p>
<p>与逻辑 OR 和逻辑 AND 运算符不同的是，逻辑 NOT 运算符返回的一定是 Boolean 值。</p>
<p>逻辑 NOT 运算符的行为如下：</p>
<ul>
<li>如果运算数是对象，返回 false</li>
<li>如果运算数是数字 0，返回 true</li>
<li>如果运算数是 0 以外的任何数字，返回 false</li>
<li>如果运算数是 null，返回 true</li>
<li>如果运算数是 NaN，返回 true</li>
<li>如果运算数是 undefined，发生错误</li>
</ul>
<p>通常，该运算符用于控制循环：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFound = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!bFound) &#123;</span><br><span class="line">  <span class="keyword">if</span> (aValue[i] == vSearchValues) &#123;</span><br><span class="line">    bFound = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Boolean 变量（bFound）用于记录检索是否成功。找到问题中的数据项时，bFound 将被设置为 true，!bFound 将等于 false，意味着运行将跳出 while 循环。</p>
<p>判断 ECMAScript 变量的 Boolean 值时，也可以使用逻辑 NOT 运算符。这样做需要在一行代码中使用两个 NOT 运算符。无论运算数是什么类型，第一个 NOT 运算符返回 Boolean 值。第二个 NOT 将对该 Boolean 值求负，从而给出变量真正的 Boolean 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFalse = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> sRed = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iZero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> iThreeFourFive = <span class="number">345</span>;</span><br><span class="line"><span class="keyword">var</span> oObject = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;bFalse 的逻辑值是 &quot;</span> + (!!bFalse));</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;sRed 的逻辑值是 &quot;</span> + (!!sRed));</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;iZero 的逻辑值是 &quot;</span> + (!!iZero));</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;iThreeFourFive 的逻辑值是 &quot;</span> + (!!iThreeFourFive));</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;oObject 的逻辑值是 &quot;</span> + (!!oObject));</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<ul>
<li>bFalse 的逻辑值是 false</li>
<li>sRed 的逻辑值是 true</li>
<li>iZero 的逻辑值是 false</li>
<li>iThreeFourFive 的逻辑值是 true</li>
<li>oObject 的逻辑值是 true</li>
</ul>
<h4 id="逻辑-AND-运算符">逻辑 AND 运算符</h4>
<p>在 ECMAScript 中，逻辑 AND 运算符用双和号（&amp;&amp;）表示：</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bTrue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bFalse = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = bTrue &amp;&amp; bFalse;</span><br></pre></td></tr></table></figure>
<p>下面的真值表描述了逻辑 AND 运算符的行为：</p>
<table>
<thead>
<tr>
<th>运算数 1</th>
<th>运算数 2</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p><strong>逻辑 AND 运算的运算数可以是任何类型的，不止是 Boolean 值</strong>。</p>
<p>如果某个运算数不是原始的 Boolean 型值，逻辑 AND 运算并不一定返回 Boolean 值：</p>
<ul>
<li>如果一个运算数是对象，另一个是 Boolean 值，返回该对象。</li>
<li>如果两个运算数都是对象，返回第二个对象。</li>
<li>如果某个运算数是 null，返回 null。</li>
<li>如果某个运算数是 NaN，返回 NaN。</li>
<li>如果某个运算数是 undefined，发生错误。</li>
</ul>
<p>与 Java 中的逻辑 AND 运算相似，ECMAScript 中的逻辑 AND 运算也是简便运算，即如果第一个运算数决定了结果，就不再计算第二个运算数。对于逻辑 AND 运算来说，如果第一个运算数是 false，那么无论第二个运算数的值是什么，结果都不可能等于 true。</p>
<p>考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bTrue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = (bTrue &amp;&amp; bUnknown);	<span class="comment">//发生错误</span></span><br><span class="line">alert(bResult);			<span class="comment">//这一行不会执行</span></span><br></pre></td></tr></table></figure>
<p>这段代码在进行逻辑 AND 运算时将引发错误，因为变量 bUnknown 是未定义的。变量 bTrue 的值为 true，因为逻辑 AND 运算将继续计算变量 bUnknown。这样做就会引发错误，因为 bUnknown 的值是 undefined，不能用于逻辑 AND 运算。</p>
<p>如果修改这个例子，把第一个数设为 false，那么就不会发生错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFalse = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = (bFalse &amp;&amp; bUnknown);</span><br><span class="line">alert(bResult);			<span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，脚本将输出逻辑 AND 运算返回的值，即字符串 “false”。即使变量 bUnknown 的值为 undefined，它也不会被计算，因为第一个运算数的值是 false。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：在使用逻辑 AND 运算符时，必须记住它的这种简便计算特性。
</div>
<h4 id="逻辑-OR-运算符">逻辑 OR 运算符</h4>
<p>ECMAScript 中的逻辑 OR 运算符与 Java 中的相同，都由双竖线（||）表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bTrue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bFalse = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = bTrue || bFalse;</span><br></pre></td></tr></table></figure>
<p>下面的真值表描述了逻辑 OR 运算符的行为：</p>
<table>
<thead>
<tr>
<th>运算数 1</th>
<th>运算数 2</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
</tbody>
</table>
<p>与逻辑 AND 运算符相似，如果某个运算数不是 Boolean 值，逻辑 OR 运算并不一定返回 Boolean 值：</p>
<ul>
<li>如果一个运算数是对象，并且该对象左边的运算数值均为 false，则返回该对象。</li>
<li>如果两个运算数都是对象，返回第一个对象。</li>
<li>如果最后一个运算数是 null，并且其他运算数值均为 false，则返回 null。</li>
<li>如果最后一个运算数是 NaN，并且其他运算数值均为 false，则返回 NaN。</li>
<li>如果某个运算数是 undefined，发生错误。</li>
</ul>
<p>与逻辑 AND 运算符一样，逻辑 OR 运算也是简便运算。对于逻辑 OR 运算符来说，如果第一个运算数值为 true，就不再计算第二个运算数。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bTrue = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = (bTrue || bUnknown);</span><br><span class="line">alert(bResult);			<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>与前面的例子相同，变量 bUnknown 是未定义的。不过，由于变量 bTrue 的值为 true，bUnknown 不会被计算，因此输出的是 “true”。</p>
<p>如果把 bTrue 改为 false，将发生错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bFalse = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> bResult = (bFalse || bUnknown);	<span class="comment">//发生错误</span></span><br><span class="line">alert(bResult);			<span class="comment">//不会执行这一行</span></span><br></pre></td></tr></table></figure>
<h3 id="加性运算符">加性运算符</h3>
<h4 id="加法运算符">加法运算符</h4>
<p>加法运算符由加号（+）表示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>在处理特殊值时，ECMAScript 中的加法有一些特殊行为：</p>
<ul>
<li>某个运算数是 NaN，那么结果为 NaN。</li>
<li>-Infinity 加 -Infinity，结果为 -Infinity。</li>
<li>Infinity 加 -Infinity，结果为 NaN。</li>
<li>+0 加 +0，结果为 +0。</li>
<li>-0 加 +0，结果为 +0。</li>
<li>-0 加 -0，结果为 -0。</li>
</ul>
<p>不过，如果某个运算数是字符串，那么采用下列规则：</p>
<ul>
<li>如果两个运算数都是字符串，把第二个字符串连接到第一个上。</li>
<li>如果只有一个运算数是字符串，把另一个运算数转换成字符串，结果是两个字符串连接成的字符串。</li>
</ul>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">5</span> + <span class="number">5</span>;	<span class="comment">//两个数字</span></span><br><span class="line">alert(result);		<span class="comment">//输出 &quot;10&quot;</span></span><br><span class="line"><span class="keyword">var</span> result2 = <span class="number">5</span> + <span class="string">&quot;5&quot;</span>;	<span class="comment">//一个数字和一个字符串</span></span><br><span class="line">alert(result);		<span class="comment">//输出 &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>这段代码说明了加法运算符的两种模式之间的差别。正常情况下，5+5 等于 10（原始数值），如上述代码中前两行所示。不过，如果把一个运算数改为字符串 “5”，那么结果将变为 “55”（原始的字符串值），因为另一个运算数也会被转换为字符串。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：为了避免 JavaScript 中的一种常见错误，在使用加法运算符时，一定要仔细检查运算数的数据类型。
</div>
<h4 id="减法运算符">减法运算符</h4>
<p>减法运算符（-），也是一个常用的运算符：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">2</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>与加法运算符一样，在处理特殊值时，减法运算符也有一些特殊行为：</p>
<ul>
<li>某个运算数是 NaN，那么结果为 NaN。</li>
<li>Infinity 减 Infinity，结果为 NaN。</li>
<li>-Infinity 减 -Infinity，结果为 NaN。</li>
<li>Infinity 减 -Infinity，结果为 Infinity。</li>
<li>-Infinity 减 Infinity，结果为 -Infinity。</li>
<li>+0 减 +0，结果为 +0。</li>
<li>-0 减 -0，结果为 -0。</li>
<li>+0 减 -0，结果为 +0。</li>
<li>某个运算符不是数字，那么结果为 NaN。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果运算数都是数字，那么执行常规的减法运算，并返回结果。
</div>
<h3 id="乘性运算符">乘性运算符</h3>
<h4 id="乘法运算符">乘法运算符</h4>
<p>乘法运算符由星号（*）表示，用于两数相乘。</p>
<p>ECMAScript 中的乘法语法与 C 语言中的相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">12</span> * <span class="number">34</span></span><br></pre></td></tr></table></figure>
<p>不过，在处理特殊值时，ECMAScript 中的乘法还有一些特殊行为：</p>
<ul>
<li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li>
<li>如果某个运算数是 NaN，结果为 NaN。</li>
<li>Infinity 乘以 0，结果为 NaN。</li>
<li>Infinity 乘以 0 以外的任何数字，结果为 Infinity 或 -Infinity。</li>
<li>Infinity 乘以 Infinity，结果为 Infinity。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果运算数是数字，那么执行常规的乘法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。
</div>
<h4 id="除法运算符">除法运算符</h4>
<p>除法运算符由斜杠（/）表示，用第二个运算数除第一个运算数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">88</span> /<span class="number">11</span>;</span><br></pre></td></tr></table></figure>
<p>与乘法运算符相似，在处理特殊值时，除法运算符也有一些特殊行为：</p>
<ul>
<li>如果结果太大或太小，那么生成的结果是 Infinity 或 -Infinity。</li>
<li>如果某个运算数是 NaN，结果为 NaN。</li>
<li>Infinity 被 Infinity 除，结果为 NaN。</li>
<li>Infinity 被任何数字除，结果为 Infinity。</li>
<li>0 除一个任何非无穷大的数字，结果为 NaN。</li>
<li>Infinity 被 0 以外的任何数字除，结果为 Infinity 或 -Infinity。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果运算数是数字，那么执行常规的除法运算，即两个正数或两个负数为正数，两个运算数符号不同，结果为负数。
</div>
<h4 id="取模运算符">取模运算符</h4>
<p>除法（余数）运算符由百分号（%）表示，使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = <span class="number">26</span>%<span class="number">5</span>; <span class="comment">//等于 1</span></span><br></pre></td></tr></table></figure>
<p>与其他乘性运算符相似，对于特殊值，取模运算符也有特殊的行为：</p>
<ul>
<li>如果被除数是 Infinity，或除数是 0，结果为 NaN。</li>
<li>Infinity 被 Infinity 除，结果为 NaN。</li>
<li>如果除数是无穷大的数，结果为被除数。</li>
<li>如果被除数为 0，结果为 0。</li>
</ul>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果运算数是数字，那么执行常规的算术除法运算，返回除法运算得到的余数。
</div>
<h3 id="关系运算符">关系运算符</h3>
<p>关系运算符执行的是比较运算。每个关系运算符都返回一个布尔值。</p>
<h4 id="常规比较方式">常规比较方式</h4>
<p>关系运算符小于、大于、小于等于和大于等于执行的是两个数的比较运算，比较方式与算术比较运算相同。</p>
<p>每个关系运算符都返回一个布尔值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult1 = <span class="number">2</span> &gt; <span class="number">1</span>	<span class="comment">//true</span></span><br><span class="line"><span class="keyword">var</span> bResult2 = <span class="number">2</span> &lt; <span class="number">1</span>	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>不过，对两个字符串应用关系运算符，它们的行为则不同。许多人认为小于表示“在字母顺序上靠前”，大于表示“在字母顺序上靠后”，但事实并非如此。对于字符串，第一个字符串中每个字符的代码都与会第二个字符串中对应位置的字符的代码进行数值比较。完成这种比较操作后，返回一个 Boolean 值。问题在于大写字母的代码都小于小写字母的代码，这意味这着可能会遇到下列情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;Blue&quot;</span> &lt; <span class="string">&quot;alpha&quot;</span>;</span><br><span class="line">alert(bResult);	<span class="comment">//输出 true</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，字符串 “Blue” 小于 “alpha”，因为字母 B 的字符代码是 66，字母 a 的字符代码是 97。要强制性得到按照真正的字母顺序比较的结果，必须把两个数转换成相同的大小写形式（全大写或全小写的），然后再进行比较：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;Blue&quot;</span>.toLowerCase() &lt; <span class="string">&quot;alpha&quot;</span>.toLowerCase();</span><br><span class="line">alert(bResult);	<span class="comment">//输出 false</span></span><br></pre></td></tr></table></figure>
<p>把两个运算数都转换成小写，确保了正确识别出 “alpha” 在字母顺序上位于 “Blue” 之前。</p>
<h4 id="比较数字和字符串">比较数字和字符串</h4>
<p>另一种棘手的状况发生在比较两个字符串形式的数字时，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;25&quot;</span> &lt; <span class="string">&quot;3&quot;</span>;</span><br><span class="line">alert(bResult);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这段代码比较的是字符串 “25” 和 “3”。两个运算数都是字符串，所以比较的是它们的字符代码（“2” 的字符代码是 50，“3” 的字符代码是 51）。</p>
<p>不过，如果把某个运算数改为数字，那么结果就有趣了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;25&quot;</span> &lt; <span class="number">3</span>;</span><br><span class="line">alert(bResult);	<span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里，<strong>字符串 “25” 将被转换成数字 25</strong>，然后与数字 3 进行比较，结果不出所料。</p>
<p>无论何时比较一个数字和一个字符串，ECMAScript 都会把字符串转换成数字，然后按照数字顺序比较它们。</p>
<p>不过，如果字符串不能转换成数字又该如何呢？考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;a&quot;</span> &lt; <span class="number">3</span>;</span><br><span class="line">alert(bResult);</span><br></pre></td></tr></table></figure>
<p>你能预料到这段代码输出什么吗？字母 “a” 不能转换成有意义的数字。不过，如果对它调用 parseInt() 方法，返回的是 NaN。根据规则，<strong>任何包含 NaN 的关系运算符都要返回 false</strong>，因此这段代码也输出 false：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bResult = <span class="string">&quot;a&quot;</span> &gt;= <span class="number">3</span>;</span><br><span class="line">alert(bResult);</span><br></pre></td></tr></table></figure>
<p>通常，如果小于运算的两个值返回 false，那么大于等于运算必须返回 true，不过如果某个数字是 NaN，情况则非如此。</p>
<h3 id="等性运算符">等性运算符</h3>
<p>判断两个变量是否相等是程序设计中非常重要的运算。在处理原始值时，这种运算相当简单，但涉及对象，任务就稍有点复杂。
ECMAScript 提供了两套等性运算符：等号和非等号用于处理原始值，全等号和非全等号用于处理对象。</p>
<h4 id="等号和非等号">等号和非等号</h4>
<p>在 ECMAScript 中，等号由双等号（==）表示，当且仅当两个运算数相等时，它返回 true。非等号由感叹号加等号（!=）表示，当且仅当两个运算数不相等时，它返回 true。为确定两个运算数是否相等，这两个运算符都会进行类型转换。</p>
<p>执行类型转换的规则如下：</p>
<ul>
<li>如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。</li>
<li>如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。</li>
<li>如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。</li>
<li>如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。</li>
</ul>
<p>在比较时，该运算符还遵守下列规则：</p>
<ul>
<li>值 null 和 undefined 相等。</li>
<li>在检查相等性时，不能把 null 和 undefined 转换成其他值。</li>
<li>如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。</li>
<li>如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。</li>
</ul>
<div class="alert alert-warning"><i class="far fa-bell"></i>  重要提示：即使两个数都是 NaN，等号仍然返回 false，因为根据规则，NaN 不等于 NaN。
</div>
<p>下表列出了一些特殊情况，以及它们的结果：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>值</th>
</tr>
</thead>
<tbody>
<tr>
<td>null == undefined</td>
<td>true</td>
</tr>
<tr>
<td>“NaN” == NaN</td>
<td>false</td>
</tr>
<tr>
<td>5 == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN == NaN</td>
<td>false</td>
</tr>
<tr>
<td>NaN != NaN</td>
<td>true</td>
</tr>
<tr>
<td>false == 0</td>
<td>true</td>
</tr>
<tr>
<td>true == 1</td>
<td>true</td>
</tr>
<tr>
<td>true == 2</td>
<td>false</td>
</tr>
<tr>
<td>undefined == 0</td>
<td>false</td>
</tr>
<tr>
<td>null == 0</td>
<td>false</td>
</tr>
<tr>
<td>“5” == 5</td>
<td>true</td>
</tr>
</tbody>
</table>
<h4 id="全等号和非全等号">全等号和非全等号</h4>
<p>等号和非等号的同类运算符是全等号和非全等号。这两个运算符所做的与等号和非等号相同，只是它们在检查相等性前，不执行类型转换。</p>
<p>全等号由三个等号表示（===），<strong>只有在无需类型转换运算数就相等的情况下，才返回 true</strong>。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sNum = <span class="string">&quot;66&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">66</span>;</span><br><span class="line">alert(sNum == iNum);	<span class="comment">//输出 &quot;true&quot;</span></span><br><span class="line">alert(sNum === iNum);	<span class="comment">//输出 &quot;false&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，第一个 alert 使用等号来比较字符串 “66” 和数字 66，输出 “true”。如前所述，这是因为字符串 “66” 将被转换成数字 66，，然后才与另一个数字 66 进行比较。第二个 alert 使用全等号在没有类型转换的情况下比较字符串和数字，当然，字符串不等于数字，所以输出 “false”。</p>
<p>非全等号由感叹号加两个等号（!==）表示，只有在无需类型转换运算数不相等的情况下，才返回 true。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sNum = <span class="string">&quot;66&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">66</span>;</span><br><span class="line">alert(sNum != iNum);	<span class="comment">//输出 &quot;false&quot;</span></span><br><span class="line">alert(sNum !== iNum);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里，第一个 alert 使用非等号，把字符串 “66” 转换成数字 66，使得它与第二个运算数 66 相等。因此，计算结果为 “false”，因为两个运算数是相等的。第二个 alert 使用的非全等号。该运算是在问：“sNum” 与 “iNum” 不同吗？这个问题的答案是：是的（true），因为 sNum 是字符串，而 iNum 是数字，它们当然不同。</p>
<h3 id="条件运算符">条件运算符</h3>
<p>条件运算符是 ECMAScript 中功能最多的运算符，它的形式与 Java 中的相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = boolean_expression ? true_value : false_value;</span><br></pre></td></tr></table></figure>
<p>该表达式主要是根据 boolean_expression 的计算结果有条件地为变量赋值。如果 Boolean_expression 为 true，就把 true_value 赋给变量；如果它是 false，就把 false_value 赋给变量。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iMax = (iNum1 &gt; iNum2) ? iNum1 : iNum2;</span><br></pre></td></tr></table></figure>
<p>在这里例子中，iMax 将被赋予数字中的最大值。表达式声明如果 iNum1 大于 iNum2，则把 iNum1 赋予 iMax。但如果表达式为 false（即 iNum2 大于或等于 iNum1），则把 iNum2 赋予 iMax。</p>
<h3 id="赋值运算符">赋值运算符</h3>
<p>简单的赋值运算符由等号（=）实现，只是把等号右边的值赋予等号左边的变量。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>复合赋值运算是由乘性运算符、加性运算符或位移运算符加等号（=）实现的。这些赋值运算符是下列这些常见情况的缩写形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum = iNum + <span class="number">10</span>；</span><br></pre></td></tr></table></figure>
<p>可以用一个复合赋值运算符改写第二行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">10</span>;</span><br><span class="line">iNum += <span class="number">10</span>；</span><br></pre></td></tr></table></figure>
<p>每种主要的算术运算以及其他几个运算都有复合赋值运算符：</p>
<ul>
<li>乘法/赋值（*=）</li>
<li>除法/赋值（/=）</li>
<li>取模/赋值（%=）</li>
<li>加法/赋值（+=）</li>
<li>减法/赋值（-=）</li>
<li>左移/赋值（&lt;&lt;=）</li>
<li>有符号右移/赋值（&gt;&gt;=）</li>
<li>无符号右移/赋值（&gt;&gt;&gt;=）</li>
</ul>
<h3 id="逗号运算符">逗号运算符</h3>
<p>用逗号运算符可以在一条语句中执行多个运算。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum1 = <span class="number">1</span>, iNum = <span class="number">2</span>, iNum3 = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>逗号运算符常用变量声明中。</p>
<h2 id="语句">语句</h2>
<h3 id="条件语句">条件语句</h3>
<h4 id="if-语句">if 语句</h4>
<p>if 语句是 ECMAScript 中最常用的语句之一，事实上在许多计算机语言中都是如此。</p>
<p>if 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) statement1 <span class="keyword">else</span> statement2</span><br></pre></td></tr></table></figure>
<p>其中 condition 可以是任何表达式，计算的结果甚至不必是真正的 boolean 值，ECMAScript 会把它转换成 boolean 值。</p>
<p>如果条件计算结果为 true，则执行 statement1；如果条件计算结果为 false，则执行 statement2。</p>
<p>每个语句都可以是单行代码，也可以是代码块。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">30</span>)</span><br><span class="line">  &#123;alert(<span class="string">&quot;大于 30&quot;</span>);&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;alert(<span class="string">&quot;小于等于 30&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>提示：使用代码块被认为是一种最佳的编程实践，即使要执行的代码只有一行。这样做可以使每个条件要执行什么一目了然。</p>
<p>还可以串联多个 if 语句。就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1) statement1 <span class="keyword">else</span> <span class="keyword">if</span> (condition2) statement2 <span class="keyword">else</span> statement3</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">30</span>) &#123;</span><br><span class="line">  alert(<span class="string">&quot;大于 30&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">  alert(<span class="string">&quot;小于 0&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  alert(<span class="string">&quot;在 0 到 30 之间&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="switch-语句">switch 语句</h4>
<p>switch 语句是 if 语句的兄弟语句。</p>
<p>开发者可以用 switch 语句为表达式提供一系列的情况（case）。</p>
<p>switch 语句的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> value: statement;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: statement;</span><br></pre></td></tr></table></figure>
<p>每个情况（case）都是表示“如果 expression 等于 value，就执行 statement”。</p>
<p>关键字 break 会使代码跳出 switch 语句。如果没有关键字 break，代码执行就会继续进入下一个 case。</p>
<p>关键字 default 说明了表达式的结果不等于任何一种情况时的操作（事实上，它相对于 else 从句）。</p>
<p>switch 语句主要是为避免让开发者编写下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">20</span>)</span><br><span class="line">  alert(<span class="string">&quot;20&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">30</span>)</span><br><span class="line">  alert(<span class="string">&quot;30&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">40</span>)</span><br><span class="line">  alert(<span class="string">&quot;40&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  alert(<span class="string">&quot;other&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>等价的 switch 语句是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">20</span>: alert(<span class="string">&quot;20&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">30</span>: alert(<span class="string">&quot;30&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">40</span>: alert(<span class="string">&quot;40&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: alert(<span class="string">&quot;other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ECMAScript-和-Java-中的-switch-语句">ECMAScript 和 Java 中的 switch 语句</h5>
<p>ECMAScript 和 Java 中的 switch 语句有两点不同。在 ECMAScript 中，switch 语句可以用于字符串，而且能用不是常量的值说明情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BLUE = <span class="string">&quot;blue&quot;</span>, RED = <span class="string">&quot;red&quot;</span>, GREEN  = <span class="string">&quot;green&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (sColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> BLUE: alert(<span class="string">&quot;Blue&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> RED: alert(<span class="string">&quot;Red&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> GREEN: alert(<span class="string">&quot;Green&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: alert(<span class="string">&quot;Other&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，switch 语句用于字符串 sColor，声明 case 使用的是变量 BLUE、RED 和 GREEN，这在 ECMAScript 中是完全有效的。</p>
<h3 id="循环语句">循环语句</h3>
<h4 id="do-while-语句">do-while 语句</h4>
<p>do-while 语句是后测试循环，即退出条件在执行循环内部的代码之后计算。这意味着在计算表达式之前，至少会执行循环主体一次。</p>
<p>它的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;statement&#125; <span class="keyword">while</span> (expression);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;i += <span class="number">2</span>;&#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h4 id="while-语句">while 语句</h4>
<p>while 语句是前测试循环。这意味着退出条件是在执行循环内部的代码之前计算的。因此，循环主体可能根本不被执行。</p>
<p>它的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) statement</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  i += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="for-语句">for 语句</h4>
<p>for 语句是前测试循环，而且在进入循环之前，能够初始化变量，并定义循环后要执行的代码。</p>
<p>它的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; expression; post-loop-expression) statement</span><br></pre></td></tr></table></figure>
<p>注意：post-loop-expression 之后不能写分号，否则无法运行。</p>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iCount = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; iCount; i++) &#123;</span><br><span class="line">  alert(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了初始值为 0 的变量 i。只有当条件表达式（i &lt; iCount）的值为 true 时，才进入 for 循环，这样循环主体可能不被执行。如果执行了循环主体，那么将执行循环后表达式，并迭代变量 i。</p>
<h4 id="for-in-语句">for-in 语句</h4>
<p>for 语句是严格的迭代语句，用于枚举对象的属性。</p>
<p>它的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (property in expression) statement</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (sProp <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">  alert(sProp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，for-in 语句用于显示 window 对象的所有属性。前面讨论过的 PropertyIsEnumerable() 是 ECMAScript 中专门用于说明属性是否可以用 for-in 语句访问的方法。</p>
<h4 id="标签语句">标签语句</h4>
<p>可以用下列语句给语句加标签，以便以后调用（有点类似 C 语言的 goto）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label : statement</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start : i = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，标签 start 可以被之后的 <a href="#break-%E8%AF%AD%E5%8F%A5%E5%92%8C-continue-%E8%AF%AD%E5%8F%A5">break 或 continue 语句</a> 语句引用。</p>
<h4 id="break-语句和-continue-语句">break 语句和 continue 语句</h4>
<p>break 语句可以立即退出循环，阻止再次反复执行任何代码。而 continue 语句只是退出当前循环，根据控制表达式还允许继续进行下一次循环。</p>
<p>break 语句和 continue 语句都可以与有标签的语句联合使用，返回代码中的特定位置。</p>
<p>通常，当循环内部还有循环时，会这样做，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span> outermost;</span><br><span class="line">  &#125;</span><br><span class="line">  iNum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;55&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，标签 outermost 表示的是第一个 for 语句。正常情况下，每个 for 语句执行 10 次代码块，这意味着 iNum++ 正常情况下将被执行 100 次，在执行完成时，iNum 应该等于 100。这里的 break 语句有一个参数，即停止循环后要跳转到的语句的标签。这样 break 语句不止能跳出内部 for 语句（即使用变量 j 的语句），还能跳出外部 for 语句（即使用变量 i 的语句）。因此，iNum 最后的值是 55，因为当 i 和 j 的值都等于 5 时，循环将终止。</p>
<p>可以以相同的方式使用 continue 语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span> outermost;</span><br><span class="line">  &#125;</span><br><span class="line">  iNum++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(iNum);	<span class="comment">//输出 &quot;95&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上例中，continue 语句会迫使循环继续，不止是内部循环，外部循环也如此。当 j 等于 5 时出现这种情况，意味着内部循环将减少 5 次迭代，致使 iNum 的值为 95。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：可以看出，与 break 和 continue 联合使用的有标签语句非常强大，不过过度使用它们会给调试代码带来麻烦。要确保使用的标签具有说明性，同时不要嵌套太多层循环。
</div>
<h3 id="with-语句">with 语句</h3>
<p>with 语句用于设置代码在特定对象中的作用域。</p>
<p>它的语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (expression) statement</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sMessage = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="function"><span class="title">with</span>(<span class="params">sMessage</span>)</span> &#123;</span><br><span class="line">  alert(toUpperCase());	<span class="comment">//输出 &quot;HELLO&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，with 语句用于字符串，所以在调用 toUpperCase() 方法时，解释程序将检查该方法是否是本地函数。如果不是，它将检查伪对象 sMessage，看它是否为该对象的方法。然后，alert 输出 “HELLO”，因为解释程序找到了字符串 “hello” 的 toUpperCase() 方法。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：with 语句是运行缓慢的代码块，尤其是在已设置了属性值时。大多数情况下，如果可能，最好避免使用它。
<p>在 <a href="/wiki/javascript-es5.html#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F">ECMAScript 5 的严格模式中</a>，with 已经被禁用。</p>
</div>
<h2 id="函数">函数</h2>
<p>函数是由这样的方式进行声明的：关键字 function、函数名、一组参数，以及置于括号中的待执行代码。</p>
<p>函数的基本语法是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0, arg1, ... argN</span>) </span>&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">sName, sMessage</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello &quot;</span> + sName + sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果您想调用上例中的那个函数，可以使用如下的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sayHi(<span class="string">&quot;David&quot;</span>, <span class="string">&quot; Nice to meet you!&quot;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="返回值">返回值</h3>
<p>函数 sayHi() 未返回值，不过不必专门声明它（像在 Java 中使用 void 那样）。</p>
<p>即使函数确实有值，也不必明确地声明它。该函数只需要使用 return 运算符后跟要返回的值即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">iNum1, iNum2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iNum1 + iNum2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码把 sum 函数返回的值赋予一个变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iResult = sum(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">alert(iResult);	<span class="comment">//输出 &quot;2&quot;</span></span><br></pre></td></tr></table></figure>
<p>另一个重要概念是，与在 Java 中一样，函数在执行过 return 语句后立即停止代码。因此，return 语句后的代码都不会被执行。</p>
<p>例如，在下面的代码中，alert 窗口就不会显示出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">iNum1, iNum2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> iNum1 + iNum2;</span><br><span class="line">  alert(iNum1 + iNum2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个函数中可以有多个 return 语句，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">iNum1, iNum2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (iNum1 &gt; iNum2) &#123;</span><br><span class="line">    <span class="keyword">return</span> iNum1 - iNum2;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> iNum2 - iNum1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数用于返回两个数的差。要实现这一点，必须用较大的数减去较小的数，因此用 if 语句决定执行哪个 return 语句。</p>
<p>如果函数无返回值，那么可以调用没有参数的 return 运算符，随时退出函数。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">sMessage</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (sMessage == <span class="string">&quot;bye&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码中，如果 sMessage 等于 “bye”，就永远不显示警告框。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：如果函数无明确的返回值，或调用了没有参数的 return 语句，那么它真正返回的值是 undefined。
</div>
<h3 id="arguments-对象">arguments 对象</h3>
<p>在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。</p>
<p>例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0] 也可以访问这个值，即第一个参数的值（第一个参数位于位置 0，第二个参数位于位置 1，依此类推）。</p>
<p>因此，无需明确命名参数，就可以重写函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>[<span class="number">0</span>] == <span class="string">&quot;bye&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检测参数个数">检测参数个数</h3>
<p>还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。</p>
<p>下面的代码将输出每次调用函数使用的参数个数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">howManyArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">howManyArgs(<span class="string">&quot;string&quot;</span>, <span class="number">45</span>);</span><br><span class="line">howManyArgs();</span><br><span class="line">howManyArgs(<span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>上面这段代码将依次显示 “2”、“0” 和 “1”。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  注释：与其他程序设计语言不同，ECMAScript 不会验证传递给函数的参数个数是否等于函数定义的参数个数。开发者定义的函数都可以接受任意个数的参数（根据 Netscape 的文档，最多可接受 255 个），而不会引发任何错误。任何遗漏的参数都会以 undefined 传递给函数，多余的函数将忽略。
</div>
<h3 id="模拟函数重载">模拟函数重载</h3>
<p>用 arguments 对象判断传递给函数的参数个数，即可模拟函数重载：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>) &#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="number">5</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>) &#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + <span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(<span class="number">10</span>);	<span class="comment">//输出 &quot;15&quot;</span></span><br><span class="line">doAdd(<span class="number">40</span>, <span class="number">20</span>);	<span class="comment">//输出 &quot;60&quot;</span></span><br></pre></td></tr></table></figure>
<p>当只有一个参数时，doAdd() 函数给参数加 5。如果有两个参数，则会把两个参数相加，返回它们的和。所以，doAdd(10) 输出的是 “15”，而 doAdd(40, 20) 输出的是 “60”。</p>
<p>虽然不如重载那么好，不过已足以避开 ECMAScript 的这种限制。</p>
<h3 id="Function-对象（类）">Function 对象（类）</h3>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  ECMAScript 的函数实际上是功能完整的对象。
</div>
<p>Function 类可以表示开发者定义的任何函数。用 Function 类直接创建函数的语法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> function_name = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg1, arg2, ..., argN, function_body</span>)</span></span><br></pre></td></tr></table></figure>
<p>在上面的形式中，每个 arg 都是一个参数，最后一个参数是函数主体（要执行的代码）。这些参数必须是字符串。</p>
<p>记得下面这个函数吗？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">sName, sMessage</span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hello &quot;</span> + sName + sMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以这样定义它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sayHi </span><br><span class="line">= </span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;sName&quot;</span>, <span class="string">&quot;sMessage&quot;</span>, <span class="string">&quot;alert(\&quot;Hello \&quot; + sName + sMessage);&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>虽然由于字符串的关系，这种形式写起来有些困难，但有助于理解函数只不过是一种引用类型，它们的行为与用 Function 类明确创建的函数行为是相同的。</p>
<p>请看下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doAdd(<span class="number">10</span>);	<span class="comment">//输出 &quot;20&quot;</span></span><br></pre></td></tr></table></figure>
<p>如你所知，第二个函数重写了第一个函数，使 doAdd(10) 输出了 “20”，而不是 “30”。</p>
<p>如果以下面的形式重写该代码块，这个概念就清楚了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doAdd = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;iNum&quot;</span>, <span class="string">&quot;alert(iNum + 20)&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> doAdd = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;iNum&quot;</span>, <span class="string">&quot;alert(iNum + 10)&quot;</span>);</span><br><span class="line">doAdd(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>请观察这段代码，很显然，doAdd 的值被改成了指向不同对象的指针。函数名只是指向函数对象的引用值，行为就像其他对象一样。甚至可以使两个变量指向同一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doAdd = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;iNum&quot;</span>, <span class="string">&quot;alert(iNum + 10)&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> alsodoAdd = doAdd;</span><br><span class="line">doAdd(<span class="number">10</span>);	<span class="comment">//输出 &quot;20&quot;</span></span><br><span class="line">alsodoAdd(<span class="number">10</span>);	<span class="comment">//输出 &quot;20&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这里，变量 doAdd 被定义为函数，然后 alsodoAdd 被声明为指向同一个函数的指针。用这两个变量都可以执行该函数的代码，并输出相同的结果 - “20”。因此，如果函数名只是指向函数的变量，那么可以把函数作为参数传递给另一个函数吗？回答是肯定的！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callAnotherFunc</span>(<span class="params">fnFunction, vArgument</span>) </span>&#123;</span><br><span class="line">  fnFunction(vArgument);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> doAdd = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&quot;iNum&quot;</span>, <span class="string">&quot;alert(iNum + 10)&quot;</span>);</span><br><span class="line"></span><br><span class="line">callAnotherFunc(doAdd, <span class="number">10</span>);	<span class="comment">//输出 &quot;20&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的例子中，callAnotherFunc() 有两个参数 - 要调用的函数和传递给该函数的参数。这段代码把 doAdd() 传递给 callAnotherFunc() 函数，参数是 10，输出 “20”。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：尽管可以使用 Function 构造函数创建函数，但最好不要使用它，因为用它定义函数比用传统方式要慢得多。不过，所有函数都应看作 Function 类的实例。
</div>
<h4 id="Function-对象的-length-属性">Function 对象的 length 属性</h4>
<p>如前所述，函数属于引用类型，所以它们也有属性和方法。</p>
<p>ECMAScript 定义的属性 length 声明了函数期望的参数个数。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;Hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(doAdd.length);	<span class="comment">//输出 &quot;1&quot;</span></span><br><span class="line">alert(sayHi.length);	<span class="comment">//输出 &quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<p>函数 doAdd() 定义了一个参数，因此它的 length 是 1；sayHi() 没有定义参数，所以 length 是 0。</p>
<p>记住，无论定义了几个参数，ECMAScript 可以接受任意多个参数（最多 25 个），这一点在《函数概述》这一章中讲解过。属性 length 只是为查看默认情况下预期的参数个数提供了一种简便方式。</p>
<h4 id="Function-对象的方法">Function 对象的方法</h4>
<p>Function 对象也有与所有对象共享的 valueOf() 方法和 toString() 方法。这两个方法返回的都是函数的源代码，在调试时尤其有用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">iNum</span>) </span>&#123;</span><br><span class="line">  alert(iNum + <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.write(doAdd.toString());</span><br></pre></td></tr></table></figure>
<p>上面这段代码输出了 doAdd() 函数的文本。</p>
<h3 id="闭包">闭包</h3>
<h4 id="简单的闭包实例">简单的闭包实例</h4>
<p>在 ECMAScript 中使用全局变量是一个简单的闭包实例。请思考下面这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sMessage = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHelloWorld</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(sMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHelloWorld();</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，脚本被载入内存后，并没有为函数 sayHelloWorld() 计算变量 sMessage 的值。该函数捕获 sMessage 的值只是为了以后的使用，也就是说，解释程序知道在调用该函数时要检查 sMessage 的值。sMessage 将在函数调用 sayHelloWorld() 时（最后一行）被赋值，显示消息 “hello world”。</p>
<h4 id="复杂的闭包实例">复杂的闭包实例</h4>
<p>在一个函数中定义另一个会使闭包变得更加复杂。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iBaseNum = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addNum</span>(<span class="params">iNum1, iNum2</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iNum1 + iNum2 + iBaseNum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doAdd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。</p>
<p>这里要掌握的重要概念是，doAdd() 函数根本不接受参数，它使用的值是从执行环境中获取的。</p>
<p>可以看到，闭包是 ECMAScript 中非常强大多用的一部分，可用于执行复杂的计算。</p>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  提示：就像使用任何高级函数一样，使用闭包要小心，因为它们可能会变得非常复杂。
</div>
<h2 id="面向对象">面向对象</h2>
<h3 id="面向对象术语">面向对象术语</h3>
<h4 id="对象">对象</h4>
<p>ECMA-262 把对象（object）定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p>
<p>尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词（人、地点或事物）的表示。</p>
<h4 id="类">类</h4>
<p>每个对象都由类定义，可以把类看做对象的配方。类不仅要定义对象的接口（interface）（开发者访问的属性和方法），还要定义对象的内部工作（使属性和方法发挥作用的代码）。编译器和解释程序都根据类的说明构建对象。</p>
<h4 id="实例">实例</h4>
<p>程序使用类创建对象时，生成的对象叫作类的实例（instance）。对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。由类创建对象实例的过程叫做实例化（instantiation）。</p>
<p>在前面的章节我们提到过，ECMAScript 并没有正式的类。相反，ECMA-262 把对象定义描述为对象的配方。这是 ECMAScript 逻辑上的一种折中方案，因为对象定义实际上是对象自身。即使类并不真正存在，我们也把对象定义叫做类，因为大多数开发者对此术语更熟悉，而且从功能上说，两者是等价的。</p>
<h4 id="面向对象语言的要求">面向对象语言的要求</h4>
<p>一种面向对象语言需要向开发者提供四种基本能力：</p>
<ul>
<li>封装 - 把相关的信息（无论数据或方法）存储在对象中的能力</li>
<li>聚集 - 把一个对象存储在另一个对象内的能力</li>
<li>继承 - 由另一个类（或多个类）得来类的属性和方法的能力</li>
<li>多态 - 编写能以多种方法运行的函数或方法的能力</li>
</ul>
<p>ECMAScript 支持这些要求，因此可被是看做面向对象的。</p>
<h4 id="对象的构成">对象的构成</h4>
<p>在 ECMAScript 中，对象由特性（attribute）构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法（method），否则该特性被看作对象的属性（property）。</p>
<h3 id="对象应用">对象应用</h3>
<div class="alert alert-success"><i class="fas fa-lightbulb"></i>  对象的创建和销毁都在 JavaScript 执行过程中发生，理解这种范式的含义对理解整个语言至关重要。
</div>
<h4 id="声明和实例化">声明和实例化</h4>
<p>对象的创建方式是用关键字 new 后面跟上实例化的类的名字：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oObject = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>();</span><br></pre></td></tr></table></figure>
<p>第一行代码创建了 Object 类的一个实例，并把它存储到变量 oObject 中。第二行代码创建了 String 类的一个实例，把它存储在变量 oStringObject 中。如果构造函数无参数，括号则不是必需的。因此可以采用下面的形式重写上面的两行代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oObject = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> oStringObject = <span class="keyword">new</span> <span class="built_in">String</span>;</span><br></pre></td></tr></table></figure>
<h4 id="对象引用">对象引用</h4>
<p>在前面的章节中，我们介绍了引用类型的概念。在 ECMAScript 中，不能访问对象的物理表示，只能访问对象的引用。每次创建对象，存储在变量中的都是该对象的引用，而不是对象本身。</p>
<h4 id="对象废除">对象废除</h4>
<p>ECMAScript 拥有无用存储单元收集程序（garbage collection routine），意味着不必专门销毁对象来释放内存。当再没有对对象的引用时，称该对象被废除（dereference）了。运行无用存储单元收集程序时，所有废除的对象都被销毁。每当函数执行完它的代码，无用存储单元收集程序都会运行，释放所有的局部变量，还有在一些其他不可预知的情况下，无用存储单元收集程序也会运行。
把对象的所有引用都设置为 null，可以强制性地废除对象。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oObject = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="comment">// do something with the object here</span></span><br><span class="line">oObject = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>当变量 oObject 设置为 null 后，对第一个创建的对象的引用就不存在了。这意味着下次运行无用存储单元收集程序时，该对象将被销毁。</p>
<p>每用完一个对象后，就将其废除，来释放内存，这是个好习惯。这样还确保不再使用已经不能访问的对象，从而防止程序设计错误的出现。此外，旧的浏览器（如 IE/MAC）没有全面的无用存储单元收集程序，所以在卸载页面时，对象可能不能被正确销毁。废除对象和它的所有特性是确保内存使用正确的最好方法。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：废除对象的所有引用时要当心。如果一个对象有两个或更多引用，则要正确废除该对象，必须将其所有引用都设置为 null。
</div>
<h4 id="早绑定和晚绑定">早绑定和晚绑定</h4>
<p>所谓绑定（binding），即把对象的接口与对象实例结合在一起的方法。</p>
<p>早绑定（early binding）是指在实例化对象之前定义它的属性和方法，这样编译器或解释程序就能够提前转换机器代码。在 Java 和 Visual Basic 这样的语言中，有了早绑定，就可以在开发环境中使用 IntelliSense（即给开发者提供对象中属性和方法列表的功能）。ECMAScript 不是强类型语言，所以不支持早绑定。</p>
<p>另一方面，晚绑定（late binding）指的是编译器或解释程序在运行前，不知道对象的类型。使用晚绑定，无需检查对象的类型，只需检查对象是否支持属性和方法即可。ECMAScript 中的所有变量都采用晚绑定方法。这样就允许执行大量的对象操作，而无任何惩罚。</p>
<h3 id="对象类型">对象类型</h3>
<p>在 ECMAScript 中，所有对象并非同等创建的。</p>
<p>一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。</p>
<h4 id="本地对象">本地对象</h4>
<p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。它们包括：</p>
<ul>
<li>Object</li>
<li>Function</li>
<li>Array</li>
<li>String</li>
<li>Boolean</li>
<li>Number</li>
<li>Date</li>
<li>RegExp</li>
<li>Error</li>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
<h4 id="内置对象">内置对象</h4>
<p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。ECMA-262 只定义了两个内置对象，即 <code>Global</code> 和 <code>Math</code> （它们也是本地对象，根据定义，每个内置对象都是本地对象）。</p>
<h4 id="宿主对象">宿主对象</h4>
<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。</p>
<p>所有 BOM 和 DOM 对象都是宿主对象。</p>
<h3 id="对象作用域">对象作用域</h3>
<h4 id="公用、私有和受保护作用域">公用、私有和受保护作用域</h4>
<h5 id="概念">概念</h5>
<p>在传统的面向对象程序设计中，主要关注于公用和私有作用域。公用作用域中的对象属性可以从对象外部访问，即开发者创建对象的实例后，就可使用它的公用属性。而私有作用域中的属性只能在对象内部访问，即对于外部世界来说，这些属性并不存在。这意味着如果类定义了私有属性和方法，则它的子类也不能访问这些属性和方法。</p>
<p>受保护作用域也是用于定义私有的属性和方法，只是这些属性和方法还能被其子类访问。</p>
<h5 id="ECMAScript-只有公用作用域">ECMAScript 只有公用作用域</h5>
<p>对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！</p>
<h5 id="建议性的解决方法">建议性的解决方法</h5>
<p>许多开发者都在网上提出了有效的属性作用域模式，解决了 ECMAScript 的这种问题。</p>
<p>由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj._color_ = <span class="string">&quot;blue&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这段代码中，属性 color 是私有的。注意，下划线并不改变属性是公用属性的事实，它只是告诉其他开发者，应该把该属性看作私有的。</p>
<p>有些开发者还喜欢用单下划线说明私有成员，例如：<code>obj._color</code>。</p>
<h4 id="静态作用域">静态作用域</h4>
<p>静态作用域定义的属性和方法任何时候都能从同一位置访问。在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 java.net.URLEncoder 类，它的函数 encode() 就是静态方法。</p>
<h5 id="ECMAScript-没有静态作用域">ECMAScript 没有静态作用域</h5>
<p>严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。还记得吗，构造函数只是函数。函数是对象，对象可以有属性和方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello.alternate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello();		<span class="comment">//输出 &quot;hello&quot;</span></span><br><span class="line">sayHello.alternate();	<span class="comment">//输出 &quot;hi&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里，方法 alternate() 实际上是函数 sayHello 的方法。可以像调用常规函数一样调用 sayHello() 输出 “hello”，也可以调用 <code>sayHello.alternate()</code> 输出 “hi”。即使如此，alternate() 也是 sayHello() 公用作用域中的方法，而不是静态方法。</p>
<h4 id="关键字-this">关键字 this</h4>
<h5 id="this-的功能">this 的功能</h5>
<p>在 ECMAScript 中，要掌握的最重要的概念之一是关键字 this 的用法，它用在对象的方法中。关键字 this 总是指向调用该方法的对象，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">oCar.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">oCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oCar.showColor();		<span class="comment">//输出 &quot;red&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，关键字 this 用在对象的 showColor() 方法中。在此环境中，this 等于 oCar。下面的代码与上面的代码的功能相同：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">oCar.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">oCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(oCar.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">oCar.showColor();		<span class="comment">//输出 &quot;red&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="使用-this-的原因">使用 this 的原因</h5>
<p>为什么使用 this 呢？因为在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。请思考下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">oCar1.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">oCar1.showColor = showColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">oCar2.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">oCar2.showColor = showColor;</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，首先用 this 定义函数 showColor()，然后创建两个对象（oCar1 和 oCar2），一个对象的 color 属性被设置为 “red”，另一个对象的 color 属性被设置为 “blue”。两个对象都被赋予了属性 showColor，指向原始的 showColor () 函数（注意这里不存在命名问题，因为一个是全局函数，而另一个是对象的属性）。调用每个对象的 showColor()，oCar1 输出是 “red”，而 oCar2 的输出是 “blue”。这是因为调用 oCar1.showColor() 时，函数中的 this 关键字等于 oCar1。调用 oCar2.showColor() 时，函数中的 this 关键字等于 oCar2。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意，<strong>引用对象的属性时，必须使用 this 关键字</strong>。例如，如果采用下面的代码，showColor() 方法不能运行：
<p>function showColor() {
alert(color);
};</p>
<p>如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量，但是不会找到。结果如何呢？该函数将在警告中显示 “null”。</p>
</div>
<h3 id="定义类或对象">定义类或对象</h3>
<p>ECMAScript 拥有很多创建对象或类的方法。</p>
<h4 id="工厂方式">工厂方式</h4>
<h5 id="原始的方式">原始的方式</h5>
<p>因为对象的属性可以在对象创建后动态定义，所有许多开发者都在 JavaScript 最初引入时编写类似下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">oCar.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">oCar.doors = <span class="number">4</span>;</span><br><span class="line">oCar.mpg = <span class="number">25</span>;</span><br><span class="line">oCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，创建对象 car。然后给它设置几个属性：它的颜色是蓝色，有四个门，每加仑油可以跑 25 英里。最后一个属性实际上是指向函数的指针，意味着该属性是个方法。执行这段代码后，就可以使用对象 car。
不过这里有一个问题，就是可能需要创建多个 car 的实例。</p>
<h5 id="解决方案：工厂方式">解决方案：工厂方式</h5>
<p>要解决该问题，开发者创造了能创建并返回特定类型的对象的工厂函数（factory function）。</p>
<p>例如，函数 createCar() 可用于封装前面列出的创建 car 对象的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">  oTempCar.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  oTempCar.doors = <span class="number">4</span>;</span><br><span class="line">  oTempCar.mpg = <span class="number">25</span>;</span><br><span class="line">  oTempCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> oTempCar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = createCar();</span><br><span class="line"><span class="keyword">var</span> oCar2 = createCar();</span><br></pre></td></tr></table></figure>
<p>在这里，第一个例子中的所有代码都包含在 createCar() 函数中。此外，还有一行额外的代码，返回 car 对象（oTempCar）作为函数值。调用此函数，将创建新对象，并赋予它所有必要的属性，复制出一个我们在前面说明过的 car 对象。因此，通过这种方法，我们可以很容易地创建 car 对象的两个版本（oCar1 和 oCar2），它们的属性完全一样。</p>
<h5 id="为函数传递参数">为函数传递参数</h5>
<p>我们还可以修改 createCar() 函数，给它传递各个属性的默认值，而不是简单地赋予属性默认值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">  oTempCar.color = sColor;</span><br><span class="line">  oTempCar.doors = iDoors;</span><br><span class="line">  oTempCar.mpg = iMpg;</span><br><span class="line">  oTempCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> oTempCar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = createCar(<span class="string">&quot;red&quot;</span>,<span class="number">4</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = createCar(<span class="string">&quot;blue&quot;</span>,<span class="number">3</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>
<p>给 createCar() 函数加上参数，即可为要创建的 car 对象的 color、doors 和 mpg 属性赋值。这使两个对象具有相同的属性，却有不同的属性值。</p>
<h5 id="在工厂函数外定义对象的方法">在工厂函数外定义对象的方法</h5>
<p>虽然 ECMAScript 越来越正式化，但创建对象的方法却被置之不理，且其规范化至今还遭人反对。一部分是语义上的原因（它看起来不像使用带有构造函数 new 运算符那么正规），一部分是功能上的原因。功能原因在于用这种方式必须创建对象的方法。前面的例子中，每次调用函数 createCar()，都要创建新函数 showColor()，意味着每个对象都有自己的 showColor() 版本。而事实上，每个对象都共享同一个函数。</p>
<p>有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法，从而避免这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">  oTempCar.color = sColor;</span><br><span class="line">  oTempCar.doors = iDoors;</span><br><span class="line">  oTempCar.mpg = iMpg;</span><br><span class="line">  oTempCar.showColor = showColor;</span><br><span class="line">  <span class="keyword">return</span> oTempCar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = createCar(<span class="string">&quot;red&quot;</span>,<span class="number">4</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = createCar(<span class="string">&quot;blue&quot;</span>,<span class="number">3</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 &quot;blue&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面这段重写的代码中，在函数 createCar() 之前定义了函数 showColor()。在 createCar() 内部，赋予对象一个指向已经存在的 showColor() 函数的指针。从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法。</p>
<p>所有这些问题都引发了开发者定义的构造函数的出现。</p>
<h4 id="构造函数方式">构造函数方式</h4>
<p>创建构造函数就像创建工厂函数一样容易。第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。除了这点不同，构造函数看起来很像工厂函数。请考虑下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = sColor;</span><br><span class="line">  <span class="built_in">this</span>.doors = iDoors;</span><br><span class="line">  <span class="built_in">this</span>.mpg = iMpg;</span><br><span class="line">  <span class="built_in">this</span>.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car(<span class="string">&quot;red&quot;</span>,<span class="number">4</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car(<span class="string">&quot;blue&quot;</span>,<span class="number">3</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>下面为您解释上面的代码与工厂方式的差别。首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值（不必明确使用 return 运算符）。</p>
<p>现在，用 new 运算符和类名 Car 创建对象，就更像 ECMAScript 中一般对象的创建方式了。</p>
<p>你也许会问，这种方式在管理函数方面是否存在于前一种方式相同的问题呢？是的。</p>
<p>就像工厂函数，构造函数会重复生成函数，为每个对象都创建独立的函数版本。不过，与工厂函数相似，也可以用外部函数重写构造函数，同样地，这么做语义上无任何意义。这正是下面要讲的原型方式的优势所在。</p>
<h4 id="原型方式">原型方式</h4>
<p>该方式利用了对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。</p>
<p>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。我们重写了前面的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">Car.prototype.doors = <span class="number">4</span>;</span><br><span class="line">Car.prototype.mpg = <span class="number">25</span>;</span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>
<p>在这段代码中，首先定义构造函数（Car），其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p>
<p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。因此，下面的代码将输出 TRUE：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(oCar1 <span class="keyword">instanceof</span> Car);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="原型方式的问题">原型方式的问题</h5>
<p>原型方式看起来是个不错的解决方案。遗憾的是，它并不尽如人意。</p>
<p>首先，这个构造函数没有参数。使用原型方式，不能通过给构造函数传递参数来初始化属性的值，因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。请思考下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">Car.prototype.doors = <span class="number">4</span>;</span><br><span class="line">Car.prototype.mpg = <span class="number">25</span>;</span><br><span class="line">Car.prototype.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Mike&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">oCar1.drivers.push(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(oCar1.drivers);	<span class="comment">//输出 &quot;Mike,John,Bill&quot;</span></span><br><span class="line">alert(oCar2.drivers);	<span class="comment">//输出 &quot;Mike,John,Bill&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，属性 drivers 是指向 Array 对象的指针，该数组中包含两个名字 “Mike” 和 “John”。由于 drivers 是引用值，Car 的两个实例都指向同一个数组。这意味着给 oCar1.drivers 添加值 “Bill”，在 oCar2.drivers 中也能看到。输出这两个指针中的任何一个，结果都是显示字符串 “Mike,John,Bill”。</p>
<p>由于创建对象时有这么多问题，你一定会想，是否有种合理的创建对象的方法呢？答案是有，需要联合使用构造函数和原型方式。</p>
<h4 id="混合的构造函数-原型方式">混合的构造函数/原型方式</h4>
<p>联合使用构造函数和原型方式，就可像用其他程序设计语言一样创建对象。这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性（方法）。结果是，所有函数都只创建一次，而每个对象都具有自己的对象属性实例。</p>
<p>我们重写了前面的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = sColor;</span><br><span class="line">  <span class="built_in">this</span>.doors = iDoors;</span><br><span class="line">  <span class="built_in">this</span>.mpg = iMpg;</span><br><span class="line">  <span class="built_in">this</span>.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Mike&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car(<span class="string">&quot;red&quot;</span>,<span class="number">4</span>,<span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car(<span class="string">&quot;blue&quot;</span>,<span class="number">3</span>,<span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.drivers.push(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line"></span><br><span class="line">alert(oCar1.drivers);	<span class="comment">//输出 &quot;Mike,John,Bill&quot;</span></span><br><span class="line">alert(oCar2.drivers);	<span class="comment">//输出 &quot;Mike,John&quot;</span></span><br></pre></td></tr></table></figure>
<p>现在就更像创建一般对象了。所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。此外，给 oCar1 的 drivers 数组添加 “Bill” 值，不会影响到 oCar2 的数组，所以输出这些数组的值时，oCar1.drivers 显示的是 “Mike,John,Bill”，而 oCar2.drivers 显示的是 “Mike,John”。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p>
<p>这种方式是 ECMAScript 采用的主要方式，它具有其他方式的特性，却没有他们的副作用。不过，有些开发者仍觉得这种方法不够完美。</p>
<h4 id="动态原型方法">动态原型方法</h4>
<p>批评混合的构造函数/原型方式的人认为，在构造函数内部定义属性，在其外部定义方法的做法不合逻辑。因此，他们设计了动态原型方法，以提供更友好的编码风格。</p>
<p>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是用动态原型方法重写的 Car 类：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">sColor,iDoors,iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.color = sColor;</span><br><span class="line">  <span class="built_in">this</span>.doors = iDoors;</span><br><span class="line">  <span class="built_in">this</span>.mpg = iMpg;</span><br><span class="line">  <span class="built_in">this</span>.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Mike&quot;</span>,<span class="string">&quot;John&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Car._initialized == <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    Car.prototype.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">this</span>.color);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Car._initialized = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直到检查 typeof Car._initialized 是否等于 “undefined” 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了（它的值为 true 时，typeof 的值为 Boolean），那么就不再创建该方法。简而言之，该方法使用标志（_initialized）来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p>
<h4 id="混合工厂方式">混合工厂方式</h4>
<p>这种方式通常是在不能应用前一种方式时的变通方法。它的目的是创建假构造函数，只返回另一种对象的新实例。</p>
<p>这段代码看起来与工厂函数非常相似：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">  oTempCar.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">  oTempCar.doors = <span class="number">4</span>;</span><br><span class="line">  oTempCar.mpg = <span class="number">25</span>;</span><br><span class="line">  oTempCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oTempCar;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br></pre></td></tr></table></figure>
<p>由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符（位于构造函数之外），在构造函数内部创建的对象被传递回变量 car。</p>
<p>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：<strong>除非万不得已，还是避免使用这种方式。</strong></p>
<h5 id="采用哪种方式">采用哪种方式</h5>
<p>如前所述，目前使用最广泛的是混合的构造函数/原型方式。此外，动态原始方法也很流行，在功能上与构造函数/原型方式等价。可以采用这两种方式中的任何一种。不过不要单独使用经典的构造函数或原型方式，因为这样会给代码引入问题。</p>
<h3 id="修改对象">修改对象</h3>
<p>通过使用 ECMAScript，不仅可以创建对象，还可以修改已有对象的行为。</p>
<p>prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。</p>
<h4 id="创建新方法">创建新方法</h4>
<h5 id="通过已有的方法创建新方法">通过已有的方法创建新方法</h5>
<p>可以用 prototype 属性为任何已有的类定义新方法，就像处理自己的类一样。例如，还记得 Number 类的 toString() 方法吗？如果给它传递参数 16，它将输出十六进制的字符串。如果这个方法的参数是 2，那么它将输出二进制的字符串。我们可以创建一个方法，可以把数字对象直接转换为十六进制字符串。创建这个方法非常简单：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toHexString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.toString(<span class="number">16</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在此环境中，关键字 this 指向 Number 的实例，因此可完全访问 Number 的所有方法。有了这段代码，可实现下面的操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iNum = <span class="number">15</span>;</span><br><span class="line">alert(iNum.toHexString());		<span class="comment">//输出 &quot;F&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于数字 15 等于十六进制中的 F，因此警告将显示 “F”。</p>
<h5 id="重命名已有方法">重命名已有方法</h5>
<p>我们还可以为已有的方法命名更易懂的名称。例如，可以给 Array 类添加两个方法 enqueue() 和 dequeue()，只让它们反复调用已有的 push() 和 shift() 方法即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.enqueue = <span class="function"><span class="keyword">function</span>(<span class="params">vItem</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.push(vItem);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.dequeue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.shift();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="添加与已有方法无关的方法">添加与已有方法无关的方法</h5>
<p>当然，还可以添加与已有方法无关的方法。例如，假设要判断某个项在数组中的位置，没有本地方法可以做这种事情。我们可以轻松地创建下面的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.indexOf = <span class="function"><span class="keyword">function</span> (<span class="params">vItem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vItem == <span class="built_in">this</span>[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法 indexOf() 与 String 类的同名方法保持一致，在数组中检索每个项，直到发现与传进来的项相同的项目为止。如果找到相同的项，则返回该项的位置，否则，返回 -1。有了这种定义，我们可以编写下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aColors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>);</span><br><span class="line">alert(aColors.indexOf(<span class="string">&quot;green&quot;</span>));	<span class="comment">//输出 &quot;1&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="为本地对象添加新方法">为本地对象添加新方法</h5>
<p>最后，如果想给 ECMAScript 中每个本地对象添加新方法，必须在 Object 对象的 prototype 属性上定义它。前面的章节我们讲过，所有本地对象都继承了 Object 对象，所以对 Object 对象做任何改变，都会反应在所有本地对象上。例如，如果想添加一个用警告输出对象的当前值的方法，可以采用下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.showValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.valueOf());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">25</span>;</span><br><span class="line">str.showValue();		<span class="comment">//输出 &quot;hello&quot;</span></span><br><span class="line">iNum.showValue();		<span class="comment">//输出 &quot;25&quot;</span></span><br></pre></td></tr></table></figure>
<p>这里，String 和 Number 对象都从 Object 对象继承了 showValue() 方法，分别在它们的对象上调用该方法，将显示 “hello” 和 “25”。</p>
<h4 id="重定义已有方法">重定义已有方法</h4>
<p>就像能给已有的类定义新方法一样，也可重定义已有的方法。如前面的章节所述，函数名只是指向函数的指针，因此可以轻松地指向其他函数。如果修改了本地方法，如 toString()，会出现什么情况呢？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Function code hidden&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面的代码完全合法，运行结果完全符合预期：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(sayHi.toString());	<span class="comment">//输出 &quot;Function code hidden&quot;</span></span><br></pre></td></tr></table></figure>
<p>也许你还记得，Function 对象这一章中介绍过 Function 的 toString() 方法通常输出的是函数的源代码。覆盖该方法，可以返回另一个字符串（在这个例子中，可以返回 “Function code hidden”）。不过，toString() 指向的原始函数怎么了呢？<strong>它将被无用存储单元回收程序回收，因为它被完全废弃了。没有能够恢复原始函数的方法</strong>，所以在覆盖原始方法前，<strong>比较安全的做法是存储它的指针</strong>，以便以后的使用。有时你甚至可能在新方法中调用原始方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.originalToString = <span class="built_in">Function</span>.prototype.toString;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.originalToString().length &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Function too long to display.&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.originalToString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，第一行代码把对当前 toString() 方法的引用保存在属性 originalToString 中。然后用定制的方法覆盖了 toString() 方法。新方法将检查该函数源代码的长度是否大于 100。如果是，就返回错误信息，说明该函数代码太长，否则调用 originalToString() 方法，返回函数的源代码。</p>
<h4 id="极晚绑定（Very-Late-Binding）">极晚绑定（Very Late Binding）</h4>
<p>从技术上讲，根本不存在极晚绑定。本书采用该术语描述 ECMAScript 中的一种现象，即能够在对象实例化后再定义它的方法。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">o.sayHi();</span><br></pre></td></tr></table></figure>
<p>在大多数程序设计语言中，必须在实例化对象之前定义对象的方法。这里，方法 sayHi() 是在创建 Object 类的一个实例之后来添加进来的。在传统语言中不仅没听说过这种操作，也没听说过该方法还会自动赋予 Object 对象的实例并能立即使用（接下来的一行）。</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：不建议使用极晚绑定方法，因为很难对其跟踪和记录。不过，还是应该了解这种可能。
</div>
<h3 id="继承">继承</h3>
<p>ECMAScript 实现继承的方式不止一种。这是因为 JavaScript 中的继承机制并不是明确规定的，而是通过模仿实现的。下面为您介绍几种具体的继承方式。</p>
<h4 id="对象冒充">对象冒充</h4>
<p>构想原始的 ECMAScript 时，根本没打算设计对象冒充（object masquerading）。它是在开发者开始理解函数的工作方式，尤其是如何在函数环境中使用 this 关键字后才发展出来。</p>
<p>其原理如下：构造函数使用 this 关键字给所有属性和方法赋值（即采用类声明的构造函数方式）。因为构造函数只是一个函数，所以可使 ClassA 构造函数成为 ClassB 的方法，然后调用它。ClassB 就会收到 ClassA 的构造函数中定义的属性和方法。例如，用下面的方式定义 ClassA 和 ClassB：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = sColor;</span><br><span class="line">    <span class="built_in">this</span>.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.color);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得吗？关键字 this 引用的是构造函数当前创建的对象。不过在这个方法中，this 指向的所属的对象。这个原理是把 ClassA 作为常规函数来建立继承机制，而不是作为构造函数。如下使用构造函数 ClassB 可以实现继承机制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassA;</span><br><span class="line">    <span class="built_in">this</span>.newMethod(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，为 ClassA 赋予了方法 newMethod（请记住，函数名只是指向它的指针）。然后调用该方法，传递给它的是 ClassB 构造函数的参数 sColor。最后一行代码删除了对 ClassA 的引用，这样以后就不能再调用它。</p>
<p>所有新属性和新方法都必须在删除了新方法的代码行后定义。否则，可能会覆盖超类的相关属性和方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassA;</span><br><span class="line">    <span class="built_in">this</span>.newMethod(sColor);</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为证明前面的代码有效，可以运行下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.sayColor();	<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.sayColor();	<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.sayName();		<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="对象冒充可以实现多重继承">对象冒充可以实现多重继承</h5>
<p>有趣的是，对象冒充可以支持多重继承。也就是说，一个类可以继承多个超类。用 UML 表示的多重继承机制如下图所示：</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/javascript-es3/ct_js_inheritance_implementing.gif" alt="继承机制 UML 图示实例" />
        <figcaption>继承机制 UML 图示实例</figcaption>
      </figure>
    </p>
<p>例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassZ</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassX;</span><br><span class="line">    <span class="built_in">this</span>.newMethod();</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.newMethod = ClassY;</span><br><span class="line">    <span class="built_in">this</span>.newMethod();</span><br><span class="line">    <span class="keyword">delete</span> <span class="built_in">this</span>.newMethod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里存在一个弊端，如果存在两个类 ClassX 和 ClassY 具有同名的属性或方法，ClassY 具有高优先级。因为它从后面的类继承。除这点小问题之外，用对象冒充实现多重继承机制轻而易举。</p>
<p>由于这种继承方法的流行，ECMAScript 的第三版为 Function 对象加入了两个方法，即 call() 和 apply()。</p>
<h5 id="call-方法">call() 方法</h5>
<p>call() 方法是与经典的对象冒充方法最相似的方法。它的第一个参数用作 this 的对象。其他参数都直接传递给函数自身。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) </span>&#123;</span><br><span class="line">    alert(sPrefix + <span class="built_in">this</span>.color + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.call(obj, <span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，函数 sayColor() 在对象外定义，即使它不属于任何对象，也可以引用关键字 this。对象 obj 的 color 属性等于 blue。调用 call() 方法时，第一个参数是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个和第三个参数是字符串。它们与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息 “The color is blue, a very nice color indeed.” 将被显示出来。</p>
<p>要与继承机制的对象冒充方法一起使用该方法，只需将前三行的赋值、调用和删除代码替换即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.call(<span class="built_in">this</span>, sColor);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们需要让 ClassA 中的关键字 this 等于新创建的 ClassB 对象，因此 this 是第一个参数。第二个参数 sColor 对两个类来说都是唯一的参数。</p>
<h5 id="apply-方法">apply() 方法</h5>
<p>apply() 方法有两个参数，用作 this 的对象和要传递给函数的参数的数组。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params">sPrefix,sSuffix</span>) </span>&#123;</span><br><span class="line">    alert(sPrefix + <span class="built_in">this</span>.color + sSuffix);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"></span><br><span class="line">sayColor.apply(obj, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;The color is &quot;</span>, <span class="string">&quot;a very nice color indeed.&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>这个例子与前面的例子相同，只是现在调用的是 apply() 方法。调用 apply() 方法时，第一个参数仍是 obj，说明应该赋予 sayColor() 函数中的 this 关键字值是 obj。第二个参数是由两个字符串构成的数组，与 sayColor() 函数中的参数 sPrefix 和 sSuffix 匹配，最后生成的消息仍是 “The color is blue, a very nice color indeed.”，将被显示出来。</p>
<p>该方法也用于替换前三行的赋值、调用和删除新方法的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.apply(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(sColor));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，第一个参数仍是 this，第二个参数是只有一个值 color 的数组。可以把 ClassB 的整个 arguments 对象作为第二个参数传递给 apply() 方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//this.newMethod = ClassA;</span></span><br><span class="line">    <span class="comment">//this.newMethod(color);</span></span><br><span class="line">    <span class="comment">//delete this.newMethod;</span></span><br><span class="line">    ClassA.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">    <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，只有超类中的参数顺序与子类中的参数顺序完全一致时才可以传递参数对象。如果不是，就必须创建一个单独的数组，按照正确的顺序放置参数。此外，还可使用 call() 方法。</p>
<h4 id="原型链（prototype-chaining）">原型链（prototype chaining）</h4>
<p>继承这种形式在 ECMAScript 中原本是用于原型链的。上一章介绍了定义类的原型方式。原型链扩展了这种方式，以一种有趣的方式实现继承机制。</p>
<p>在上一章学过，prototype 对象是个模板，要实例化的对象都以这个模板为基础。总而言之，prototype 对象的任何属性和方法都被传递给那个类的所有实例。原型链利用这种功能来实现继承机制。</p>
<p>如果用原型方式重定义前面例子中的类，它们将变为下列形式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</span><br></pre></td></tr></table></figure>
<p>原型方式的神奇之处在于最后一行。这里，把 ClassB 的 prototype 属性设置成 ClassA 的实例。这很有意思，因为想要 ClassA 的所有属性和方法，但又不想逐个将它们 ClassB 的 prototype 属性。还有比把 ClassA 的实例赋予 prototype 属性更好的方法吗？</p>
<div class="alert alert-warning"><i class="far fa-bell"></i>  注意：调用 ClassA 的构造函数，没有给它传递参数。这在原型链中是标准做法。要确保构造函数没有任何参数。
</div>
<p>与对象冒充相似，子类的所有属性和方法都必须出现在 prototype 属性被赋值后，因为在它之前赋值的所有方法都会被删除。为什么？因为 prototype 属性被替换成了新对象，添加了新方法的原始对象将被销毁。所以，为 ClassB 类添加 name 属性和 sayName() 方法的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可通过运行下面的例子测试这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA();</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB();</span><br><span class="line">objA.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">objB.color = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">objB.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">objA.sayColor();</span><br><span class="line">objB.sayColor();</span><br><span class="line">objB.sayName();</span><br></pre></td></tr></table></figure>
<p>此外，在原型链中，instanceof 运算符的运行方式也很独特。对 ClassB 的所有实例，instanceof 为 ClassA 和 ClassB 都返回 true。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB();</span><br><span class="line">alert(objB <span class="keyword">instanceof</span> ClassA);	<span class="comment">//输出 &quot;true&quot;</span></span><br><span class="line">alert(objB <span class="keyword">instanceof</span> ClassB);	<span class="comment">//输出 &quot;true&quot;</span></span><br></pre></td></tr></table></figure>
<p>在 ECMAScript 的弱类型世界中，这是极其有用的工具，不过使用对象冒充时不能使用它。</p>
<p>原型链的弊端是不支持多重继承。记住，原型链会用另一类型的对象重写类的 prototype 属性。</p>
<h4 id="混合方式">混合方式</h4>
<p>这种继承方式使用构造函数定义类，并非使用任何原型。对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。</p>
<p>在前一章，我们曾经讲解过创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法。用这两种方式重写前面的例子，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassA</span>(<span class="params">sColor</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.color = sColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassA.prototype.sayColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.color);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ClassB</span>(<span class="params">sColor, sName</span>) </span>&#123;</span><br><span class="line">    ClassA.call(<span class="built_in">this</span>, sColor);</span><br><span class="line">    <span class="built_in">this</span>.name = sName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ClassB.prototype = <span class="keyword">new</span> ClassA();</span><br><span class="line"></span><br><span class="line">ClassB.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在此例子中，继承机制由两行突出显示的蓝色代码实现。在第一行突出显示的代码中，在 ClassB 构造函数中，用对象冒充继承 ClassA 类的 sColor 属性。在第二行突出显示的代码中，用原型链继承 ClassA 类的方法。由于这种混合方式使用了原型链，所以 instanceof 运算符仍能正确运行。</p>
<p>下面的例子测试了这段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> ClassA(<span class="string">&quot;blue&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> objB = <span class="keyword">new</span> ClassB(<span class="string">&quot;red&quot;</span>, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">objA.sayColor();	<span class="comment">//输出 &quot;blue&quot;</span></span><br><span class="line">objB.sayColor();	<span class="comment">//输出 &quot;red&quot;</span></span><br><span class="line">objB.sayName();	<span class="comment">//输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="本文参考材料">本文参考材料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.w3school.com.cn/js/">WC3School - JavaScript 高级教程</a></li>
</ul>
<h2 id="深入阅读">深入阅读</h2>
<ul>
<li><a target="_blank" rel="noopener" href="http://www.ecma-international.org/publications/standards/Stnindex.htm">ECMAScript 规范</a></li>
</ul>


		<!-- pagination -->
		<div>
		  <center>
  		    <div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
			
			
			
	    
			
		
	
	    
			
		
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	
		<li class="prev"><a data-pjax href="/wiki/javascript-angularjs.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next"><a data-pjax href="/wiki/javascript-es5.html" class="alignright next">Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	      </center>
		</div>
				
		<!-- comment -->
		
<section id="comment">
  <h2 class="title">Comments</h2>
  
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    if ($('#gt-container').length <= 0) {
    var gitalk = new Gitalk({
        clientID: '19f93019e0c0b8fdc4b3',
        clientSecret: '00ca18ff55f2b4f0f33af3fb90ff524e7acd1032',
        id: undefined != undefined ? 'undefined' : window.location.pathname,
        repo: 'wzpan.github.io',
        owner: 'wzpan',
        admin: 'wzpan',
        proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
        title: 'ES3'
    })
    gitalk.render('gitalk-container');
    }
  </script>
  
</section>

		

	</div> <!-- span9/span12 -->
</div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
    
    
    
    
          <div class="modal fade" id="wechat-modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
            <div class="modal-dialog" role="document">
               <div class="modal-body">
                 <img src='https://hahack-1253537070.cos.ap-chengdu.myqcloud.com/images/blog/images/qrcode.jpg'/>
              </div>
            </div>
          </div>
		
    
    
    
  <footer> <p>
  &copy; 2021 wzpan
  
    <small>
     <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
  </div> <!-- container-narrow -->
  
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.imagesloaded.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/bootstrap.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.tableofcontents.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/tocgenerator.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/main.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/fadetoc.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = '/' + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>



  <script type="text/javascript">
    $(document).ready(function() {
      
         $("#freemind-cerulean").click(function(){
           document.cookie = "theme=cerulean; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=cerulean; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/cerulean.css");
         });
      
         $("#freemind-cyborg").click(function(){
           document.cookie = "theme=cyborg; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=cyborg; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/cyborg.css");
         });
      
         $("#freemind-paper").click(function(){
           document.cookie = "theme=paper; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=paper; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/paper.css");
         });
      
         $("#freemind-flatly").click(function(){
           document.cookie = "theme=flatly; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=flatly; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/flatly.css");
         });
      
         $("#freemind-journal").click(function(){
           document.cookie = "theme=journal; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=journal; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/journal.css");
         });
      
         $("#freemind-simplex").click(function(){
           document.cookie = "theme=simplex; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=simplex; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/simplex.css");
         });
      
         $("#freemind-spacelab").click(function(){
           document.cookie = "theme=spacelab; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=spacelab; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/spacelab.css");
         });
      
     });
  </script>



<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>