<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>数据结构 | HaHack</title>
  <meta name="author" content="wzpan">
  
  <meta name="description" content="“Algorithm + Data Structures = Programs” - Niklaus Wirth

栈和队列
栈和队列都是动态集合，且在其上进行 DELETE 操作所移除的元素都是预先设定的。

在栈（stack）中，被删除的是最近插入的元素；栈实现的是一种后进先出（last-in ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="数据结构"/>
  <meta property="og:site_name" content="HaHack"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="//atom.xml" title="HaHack" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  

  <!-- CSS -->
  <link rel="stylesheet" id="theme" href="/css/themes/cerulean.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight-default.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/bubble.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/article.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/css/comment.css" media="screen" type="text/css"> -->
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.9/es5-shim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/es5-shim/4.5.7/es5-sham.min.js"></script>
    <![endif]-->

  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery-2.0.3.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.pjax.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/pace.min.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/theme.js"></script>
  <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/search.js"></script>
  
    
    <link rel="stylesheet" href="/css/gitalk.css">
    <script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/gitalk.min.js"></script>
    
  <script type="text/javascript">
    $(document).ready(function() {
      $(document).pjax('a[target!=_blank][rel!=gallery]', '.pjax', {fragment:'.pjax', timeout:8000});
    });

    $(document).on('pjax:send', function() {
	  Pace.restart();
    })
    $(document).on('pjax:complete', function() {
       Pace.stop();
        
       var search_path = "search.xml";
	   if (search_path.length == 0) {
	 	search_path = "search.xml";
	   }
	   var path = '/' + search_path;
      searchFunc(path, 'local-search-input', 'local-search-result');

       $('[data-spy="affix"]').each(function () {
          var $spy = $(this)
          , data = $spy.data()
          data.offset = data.offset || {}
          data.offsetBottom && (data.offset.bottom = data.offsetBottom)
          data.offsetTop && (data.offset.top = data.offsetTop)
          $spy.affix(data)
       });

    })
    $(document).on({'pjax:end': function() {
      $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function() { 
            MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
                tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
                TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
                messageStyle: "none"
            });

            var math = document.getElementsByClassName("pjax")[0];
            MathJax.Hub.Queue(["Typeset",MathJax.Hub,math]);
            
        });
        $.getScript("//hahack-1253537070.file.myqcloud.com/images/blog/js/gallery.js");
        if ($('#gitalk-container').length > 0) {
            var gitalk = new Gitalk({
                clientID: '19f93019e0c0b8fdc4b3',
                clientSecret: '00ca18ff55f2b4f0f33af3fb90ff524e7acd1032',
                id: undefined != undefined ? 'undefined' : window.location.pathname,
                repo: 'wzpan.github.io',
                owner: 'wzpan',
                admin: 'wzpan',
                proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
                title: '数据结构'
            })
            gitalk.render('gitalk-container');
        }
      }
    })
  </script>
  <!-- analytics -->
  



<meta name="generator" content="Hexo 5.4.0"></head>

 <body data-spy="scroll" data-target=".wiki .toc">
  <nav id="main-nav" class="navbar navbar-inverse navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
       <a class="navbar-brand" href="/">HaHack</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archive" title="所有文章存档">
			  <i class="fas fa-archive"></i>Archive
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="所有文章分类.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="所有文章标签.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/wiki" title="我的笔记库">
			  <i class="fa fa-tasks"></i>wiki
			</a>
		  </li>
		  
		</ul>
        <ul class="nav navbar-nav navright">
          <li class="dropdown works">
          <a href="#" title="更换主题" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"><i class="fa fa-palette"></i></a>
          <ul class="dropdown-menu">
            
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-cerulean" title="更换颜色主题为cerulean"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#0B4C8D"></span>cerulean</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-cyborg" title="更换颜色主题为cyborg"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#272B30"></span>cyborg</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-paper" title="更换颜色主题为paper"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#2B97F0"></span>paper</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-flatly" title="更换颜色主题为flatly"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#28BB9C"></span>flatly</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-journal" title="更换颜色主题为journal"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#E96967"></span>journal</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-simplex" title="更换颜色主题为simplex"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#D7261E"></span>simplex</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" href="#" id="freemind-spacelab" title="更换颜色主题为spacelab"><span style="width:1em; height:1em; margin-top: 2px; margin-right: 5px; float: left; display: block; background:#507DAC"></span>spacelab</a></li> 
			
          </ul>
          </li>
          <li class="dropdown works">
          <a href="#" title="作品集" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Works <span class="caret"></span></a>
          <ul class="dropdown-menu">
            
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/wukong-robot" title="wukong-robot 是一个简单、灵活、优雅的中文语音对话机器人。"><i class="fab fa-github"></i>wukong-robot</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/dingdang-robot/dingdang-robot" title="叮当是一款可以工作在 Raspberry Pi 上的中文语音对话机器人/智能音箱项目。"><i class="fab fa-github"></i>dingdang-robot</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/comment.js" title="纯JS实现的静态站点评论系统，使用 Github/OSChina 作为 backend。"><i class="fab fa-github"></i>comment.js</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://github.com/wzpan/qtevm" title="首个完整的 C++ 开源实现，能同时放大动作变化和颜色变化"><i class="fab fa-github"></i>QtEVM</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/hexo-series" title="为 Hexo 写的一系列主题/工具/插件"><i class="fab fa-github"></i>hexo-series</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/scnu/scnuthesis" title="符合华南师范大学硕士/博士学位论文格式要求的LaTeX模板。"><i class="fab fa-github"></i>SCNUThesis</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://github.com/wzpan/wzpan.github.io/wiki/slides" title="一些幻灯片作品"><i class="fab fa-github"></i>Slides</a></li>
			
				   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="http://www.hahack.com/codes/fcevm/" title="硕士毕业论文"><i class="fab fa-github"></i>Dissertation</a></li>
			
            <li role="separator" class="divider"></li>
            
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/list/python%20next%20潘伟洲" title="Python 从入门到实践系列"><i class="fas fa-video"></i>Python</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/350627" title="使用Cocos Creator开发微信小游戏《2048》"><i class="fas fa-video"></i>2048</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/326820" title="微信小游戏入门与实战"><i class="fas fa-video"></i>minigame</a></li> 
			
                   <li role="presentation"><a role="menuitem" tabindex="-1" target="_blank" href="https://ke.qq.com/course/471888?_bid=167&_wv=3&term_id=100565039&taid=4061608838378320" title="微信小游戏入门与实战"><i class="fas fa-video"></i>IT大咖说</a></li> 
			
          </ul>
          </li>
          <li class="dropdown works">
            <a href="#" title="订阅本站" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Subscribe <span class="caret"></span></a>
            <ul class="dropdown-menu">
              
			    <li role="presentation"><a role="menuitem" tabindex="-1"  href="/atom.xml"  title="使用 RSS 阅读器订阅 HaHack"  ><i class="fa fa-rss-square"></i>RSS</a></li>
			  
			    <li role="presentation"><a role="menuitem" tabindex="-1"  title="订阅 HaHack 的公众平台"  data-toggle="modal" data-target="#wechat-modal" ><i class="fa fa-qrcode"></i>WeChat</a></li>
			  
			    <li role="presentation"><a role="menuitem" tabindex="-1"  target="_blank" rel="noopener" href="http://toutiao.io/u/147640"  title=""  ><i class="fa fa-align-justify"></i>Toutiao</a></li>
			   
            </ul>
          </li>
          
				<li><a data-pjax href="/about" title="关于我"><i class="fa fa-user"></i>About</a></li>				   				
   	  	  
        </ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content pjax">
      

	
		<div class="page-header page-header-inverse ">		
			<h1 class="title title-inverse "> 数据结构</h1>
		</div>		
	



<div class="row wiki">
	<!-- span -->
    
        <div class="col-md-3 toc" id="toc">
             <!-- toc -->
		     
   	<script type="text/javascript">
		jQuery(document).ready(function() {
		
           generateWikiTOC('.note', '.toc',  2 , 2 );
		
		});
	</script>



        </div>
        <div class="col-md-9 note">
    

	

		<!-- content -->
		<blockquote>
<p>“Algorithm + Data Structures = Programs” - Niklaus Wirth</p>
</blockquote>
<h2 id="栈和队列">栈和队列</h2>
<p>栈和队列都是动态集合，且在其上进行 DELETE 操作所移除的元素都是预先设定的。</p>
<ul>
<li>在栈（stack）中，被删除的是最近插入的元素；栈实现的是一种<strong>后进先出</strong>（last-in first out, LIFO）策略。</li>
<li>在队列（queue）中，被删去的总是在集合中存在时间最长的那个元素；队列实现的是一种<strong>先进先出</strong>（First-in first out, FIFO）策略。</li>
</ul>
<h3 id="栈">栈</h3>
<p>可以用一个数组 \(S[1..n]\) 来实现一个最多可容纳 \(n\) 个元素的栈。该数组有一个属性 S.top，指向最新插入的元素。栈中包含的元素为 \(S[1..S.top]\)，其中 \(S[1]\) 是栈底元素，而 \(S[S.top]\) 是栈顶元素。</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/algorithms-data-structure/stack.png" alt="栈S的数组实现" />
        <figcaption>栈S的数组实现</figcaption>
      </figure>
    </p>
<h4 id="实现">实现</h4>
<p>C语言实现的倒序打印：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>[top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>[++top] = num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">        push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!isEmpty())&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<p>链表（linked list）是一种这样的数据结构，其中的各对象按线性顺序排列。数组的线性顺序是由数组下标决定的，然而与数组不同的是，链表的顺序是由各个对象里的指针决定的。链表为动态集合提供了一种简单而灵活的表示方法，并且可以支持大多数动态集合的操作。</p>
<p>每个链表有一个头指针（head），通过头指针可以找到第一个节点，每个节点都可以通过指针域找到它的后继（next），最后一个节点的指针域为NULL，表示没有后继。数组在内存中是连续存放的，而链表在内存中的布局是不规则的，我们知道访问某个数组元素 b[n] 时可以通过 基地址+n×每个元素的字节数 得到它地址，或者说数组支持随机访问，而链表是不支持随机访问的，只能通过前一个元素的指针域得知后一个元素的地址，因此只能从头指针开始顺序访问各节点。</p>
<h3 id="定义">定义</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">&#125;Node, *list;</span><br></pre></td></tr></table></figure>
<h3 id="创建结点">创建结点</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">createNode</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = <span class="keyword">new</span> Node;</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除结点">删除结点</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeNode</span><span class="params">(Node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历所有结点">遍历所有结点</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(Node *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p-&gt;data);    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Node *head, <span class="keyword">void</span> (*visit)(Node *))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node *p = head; p; p = p-&gt;next)&#123;</span><br><span class="line">        <span class="built_in">visit</span>(p);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找结点">查找结点</h3>
<h4 id="查找第一个值为-key-的结点">查找第一个值为 key 的结点</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">searchNode</span><span class="params">(Node *head, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Node *p = head; p; p = p-&gt;next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == key) <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="查找第-pos-个位置的结点">查找第 pos 个位置的结点</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">accessNode</span> <span class="params">(Node *head, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Incorrect position!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pos &amp;&amp; p; i++)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == pos) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Incorrect position!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="插入结点">插入结点</h3>
<h4 id="头插入">头插入</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insertHead</span><span class="params">(Node *head, Node *nd)</span></span>&#123;</span><br><span class="line">    nd-&gt;next = head;</span><br><span class="line">    head = nd;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">insertHead</span><span class="params">(Node *head, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *nd = <span class="built_in">createNode</span>(data);</span><br><span class="line">    head = <span class="built_in">insertHead</span>(head, nd);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="尾插入">尾插入</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insertTail</span><span class="params">(Node *head, Node *nd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        head = nd;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node *p;</span><br><span class="line">        <span class="keyword">for</span> (p = head; p-&gt;next; p = p-&gt;next);</span><br><span class="line">        p-&gt;next = nd;</span><br><span class="line">        p = nd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">insertTail</span><span class="params">(Node *head, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *nd = <span class="built_in">createNode</span>(data);</span><br><span class="line">    head = <span class="built_in">insertTail</span>(head, nd);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="任意位置插入">任意位置插入</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">insertNode</span><span class="params">(Node *head, <span class="keyword">int</span> pos, Node *nd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Incorrect position!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span> &amp;&amp; !head)&#123;</span><br><span class="line">        head = nd;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p = <span class="built_in">accessNode</span>(head, pos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        nd-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = nd;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Incorrect position!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node* <span class="title">insertNode</span><span class="params">(Node *head, <span class="keyword">int</span> pos, <span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    Node *nd = <span class="built_in">createNode</span>(data);</span><br><span class="line">    <span class="built_in">insertNode</span>(head, pos, nd);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除结点-v2">删除结点</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">deleteNode</span><span class="params">(Node *head, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Invalidate position!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!head)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Link is empty!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>)&#123;</span><br><span class="line">        p = head;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        <span class="built_in">freeNode</span>(p);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    p = <span class="built_in">accessNode</span>(head, pos<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span> &amp;&amp; p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *item = p-&gt;next;</span><br><span class="line">        p-&gt;next = item-&gt;next;</span><br><span class="line">        <span class="built_in">freeNode</span>(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Invalidate position!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用数组初始化一个链表">用数组初始化一个链表</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">init</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;Invalidate length!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">//or: insertNode(i, a[i]);</span></span><br><span class="line">        <span class="comment">//or: insertTail(a[i]);</span></span><br><span class="line">        Node *nd = <span class="built_in">createNode</span>(a[i]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == head)&#123;</span><br><span class="line">            head = p = nd;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next = nd;</span><br><span class="line">        p = nd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="清空一个链表">清空一个链表</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">destroy</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    Node *q;</span><br><span class="line">    <span class="keyword">while</span>(p)&#123;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="built_in">freeNode</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求链表长">求链表长</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *p = head;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; p; ++i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取链表中间结点">获取链表中间结点</h3>
<p>用一个快指针和一个慢指针实现。慢指针移动的速度是快指针的一半，当快指针走完链表时，输出慢指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">accessMid</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *slow = head;</span><br><span class="line">    Node *fast = head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast)&#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; i/<span class="number">2</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单链表排序">单链表排序</h3>
<p>最简单的可以使用选择排序实现：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">selectionSort</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    Node *p, *q, *min;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">for</span> (p = head; p; p = p-&gt;next)&#123;</span><br><span class="line">        min = p;</span><br><span class="line">        <span class="keyword">for</span> (q = p; q; q = q-&gt;next)</span><br><span class="line">            <span class="keyword">if</span> (q-&gt;data &lt; min-&gt;data) min = q;</span><br><span class="line">        <span class="keyword">if</span> (min != p)&#123;</span><br><span class="line">            t = min-&gt;data;</span><br><span class="line">            min-&gt;data = p-&gt;data;</span><br><span class="line">            p-&gt;data = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="将单链表反转">将单链表反转</h3>
<p>从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转单链表  </span></span><br><span class="line"><span class="function">Node * <span class="title">reverseList</span><span class="params">(Node * pHead)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">// 如果链表为空或只有一个结点，无需反转，直接返回原链表头指针  </span></span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span> || pHead-&gt;next == <span class="literal">NULL</span>)    </span><br><span class="line">        <span class="keyword">return</span> pHead;  </span><br><span class="line">  </span><br><span class="line">    Node *pReversedHead = <span class="literal">NULL</span>; <span class="comment">// 反转后的新链表头指针，初始为NULL  </span></span><br><span class="line">    Node *pCurrent = pHead;  </span><br><span class="line">    <span class="keyword">while</span>(pCurrent != <span class="literal">NULL</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Node *pTemp = pCurrent;  </span><br><span class="line">        pCurrent = pCurrent-&gt;next;  </span><br><span class="line">        pTemp-&gt;next = pReversedHead; <span class="comment">// 将当前结点摘下，插入新链表的最前端  </span></span><br><span class="line">        pReversedHead = pTemp;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> pReversedHead;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="逆序打印单链表">逆序打印单链表</h3>
<p>对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从尾到头打印链表，使用递归  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reversePrint</span><span class="params">(Node *pHead)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">reversePrint</span>(pHead-&gt;next);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\t&quot;</span>, pHead-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断是否存在环">判断是否存在环</h3>
<p>用一个快指针和一个慢指针实现。慢指针每次移动一步，快指针就移动两步。如果两个指针能够相遇，证明存在环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoop</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *slow = head, *fast = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fast &amp;&amp; fast-&gt;next &amp;&amp; fast!=slow);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fast == slow)&#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="找出环的起点">找出环的起点</h3>
<p>当快指针和慢指针相遇后，慢指针返回链表头，快指针从相遇点开始，两个指针重新恢复一次一步的速度移动。如果再次相遇，则该相遇的地点即为环的起点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">loopstart</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == head || <span class="literal">NULL</span> == head-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *slow = head, *fast = head;</span><br><span class="line">    <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!fast || !fast-&gt;next) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != slow)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断两个单链表是否相交">判断两个单链表是否相交</h3>
<p>如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为 O(1)。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersected</span><span class="params">(Node *pHead1, Node *pHead2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    Node* pTail1 = pHead1;  </span><br><span class="line">    <span class="keyword">while</span>(pTail1-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">        pTail1 = pTail1-&gt;next;  </span><br><span class="line"></span><br><span class="line">    Node* pTail2 = pHead2;  </span><br><span class="line">    <span class="keyword">while</span>(pTail2-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">        pTail2 = pTail2-&gt;next;  </span><br><span class="line">    <span class="keyword">return</span> pTail1 == pTail2;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="求两个单链表相交的第一个节点">求两个单链表相交的第一个节点</h3>
<ol>
<li>对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。</li>
<li>对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。</li>
</ol>
<p>两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，直到两个节点的地址相同。</p>
<p>时间复杂度，O(len1+len2)。参考代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">GetFirstCommonNode</span><span class="params">(Node *pHead1, Node * pHead2)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">1</span>;  </span><br><span class="line">    Node * pTail1 = pHead1;  </span><br><span class="line">    <span class="keyword">while</span>(pTail1-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pTail1 = pTail1-&gt;next;  </span><br><span class="line">        len1++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">1</span>;  </span><br><span class="line">    Node * pTail2 = pHead2;  </span><br><span class="line">    <span class="keyword">while</span>(pTail2-&gt;next != <span class="literal">NULL</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pTail2 = pTail2-&gt;next;  </span><br><span class="line">        len2++;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(pTail1 != pTail2) <span class="comment">// 不相交直接返回NULL  </span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">    Node *pNode1 = pHead1;  </span><br><span class="line">    Node *pNode2 = pHead2;  </span><br><span class="line">    <span class="comment">// 先对齐两个链表的当前结点，使之到尾节点的距离相等  </span></span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> k = len1 - len2;  </span><br><span class="line">        <span class="keyword">while</span>(k--)  </span><br><span class="line">            pNode1 = pNode1-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> k = len2 - len1;  </span><br><span class="line">        <span class="keyword">while</span>(k--)  </span><br><span class="line">            pNode2 = pNode2-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span>(pNode1 != pNode2)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pNode1 = pNode1-&gt;next;  </span><br><span class="line">        pNode2 = pNode2-&gt;next;  </span><br><span class="line">    &#125;  </span><br><span class="line">        <span class="keyword">return</span> pNode1;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="二叉树">二叉树</h2>
<p>二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p>
<h3 id="节点定义">节点定义</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node* lchild;</span><br><span class="line">    Node* rchild;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有些实现还会带上父节点：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    Node* lchild;</span><br><span class="line">    Node* rchild;</span><br><span class="line">    Node* parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="求节点数">求节点数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，节点个数为0</li>
<li>如果二叉树不为空，二叉树节点个数 = 左子树节点个数 + 右子树节点个数 + 1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNum</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getNodeNum</span>(pRoot-&gt;lchild) + <span class="built_in">getNodeNum</span>(pRoot-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求树高">求树高</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，二叉树的树高为0</li>
<li>如果二叉树不为空，二叉树的树高 = max(左子树树高， 右子树树高) + 1</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(Node *pRoot)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ld = <span class="built_in">getDepth</span>(pRoot-&gt;lchild);</span><br><span class="line">    <span class="keyword">int</span> rd = <span class="built_in">getDepth</span>(pRoot-&gt;rchild);</span><br><span class="line">    <span class="keyword">return</span> ld &gt; rd ? (ld + <span class="number">1</span>) : (rd + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历">遍历</h3>
<h4 id="前序遍历">前序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，访问根节点，前序遍历左子树，前序遍历右子树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrderTraverse</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">visit</span>(pRoot); <span class="comment">// 访问根节点  </span></span><br><span class="line">    <span class="built_in">preOrderTraverse</span>(pRoot-&gt;lchild); <span class="comment">// 前序遍历左子树  </span></span><br><span class="line">    <span class="built_in">preOrderTraverse</span>(pRoot-&gt;rchild); <span class="comment">// 前序遍历右子树  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历">中序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，中序遍历左子树，访问根节点，中序遍历右子树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">inOrderTraverse</span>(pRoot-&gt;lchild); <span class="comment">// 中序遍历左子树  </span></span><br><span class="line">    <span class="built_in">visit</span>(pRoot); <span class="comment">// 访问根节点  </span></span><br><span class="line">    <span class="built_in">inOrderTraverse</span>(pRoot-&gt;rchild); <span class="comment">// 中序遍历右子树  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历">后序遍历</h4>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，空操作</li>
<li>如果二叉树不为空，后序遍历左子树，后序遍历右子树，访问根节点</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrderTraverse</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postOrderTraverse</span>(pRoot-&gt;lchild); <span class="comment">// 后序遍历左子树  </span></span><br><span class="line">    <span class="built_in">postOrderTraverse</span>(pRoot-&gt;rchild); <span class="comment">// 后序遍历右子树  </span></span><br><span class="line">    <span class="built_in">visit</span>(pRoot); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层序遍历">层序遍历</h4>
<p>相当于广度优先搜索，使用队列实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTraverse</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node *pNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">visit</span>(pNode); <span class="comment">// 访问节点</span></span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(pNode-&gt;lchild);</span><br><span class="line">        <span class="keyword">if</span>(pNode-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            q.<span class="built_in">push</span>(pNode-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树第K层的节点个数">求二叉树第K层的节点个数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空或者k&lt;1返回0</li>
<li>如果二叉树不为空并且k==1，返回1</li>
<li>如果二叉树不为空且k&gt;1，返回左子树中k-1层的节点个数与右子树k-1层节点个数之和</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getNodeNumKthLevel</span><span class="params">(Node *pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> numLeft = <span class="built_in">getNodeNumKthLevel</span>(pRoot-&gt;lchild, k<span class="number">-1</span>); <span class="comment">// 左子树中k-1层的节点个数  </span></span><br><span class="line">    <span class="keyword">int</span> numRight = <span class="built_in">getNodeNumKthLevel</span>(pRoot-&gt;rchild, k<span class="number">-1</span>); <span class="comment">// 右子树中k-1层的节点个数  </span></span><br><span class="line">    <span class="keyword">return</span> (numLeft + numRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树中叶子节点的个数">求二叉树中叶子节点的个数</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回0</li>
<li>如果二叉树不为空且左右子树为空，返回1</li>
<li>如果二叉树不为空，且左右子树不同时为空，返回左子树中叶子节点个数加上右子树中叶子节点个数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLeafNodeNum</span><span class="params">(Node * pRoot)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; pRoot-&gt;rchild == <span class="literal">NULL</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> numLeft = <span class="built_in">getLeafNodeNum</span>(pRoot-&gt;lchild); <span class="comment">// 左子树中叶节点的个数  </span></span><br><span class="line">    <span class="keyword">int</span> numRight = <span class="built_in">getLeafNodeNum</span>(pRoot-&gt;rchild); <span class="comment">// 右子树中叶节点的个数  </span></span><br><span class="line">    <span class="keyword">return</span> (numLeft + numRight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="判断二叉树是不是平衡二叉树">判断二叉树是不是平衡二叉树</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回真</li>
<li>如果二叉树不为空，如果左子树和右子树都是AVL树并且左子树和右子树高度相差不大于1，返回真，其他返回假</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isAVL</span><span class="params">(Node *pRoot, <span class="keyword">int</span> &amp;height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="comment">// 空树，返回真</span></span><br><span class="line">    &#123;</span><br><span class="line">        height = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> heightLeft;</span><br><span class="line">    <span class="keyword">bool</span> resultLeft = <span class="built_in">isAVL</span>(pRoot-&gt;lchild, heightLeft);</span><br><span class="line">    <span class="keyword">int</span> heightRight;</span><br><span class="line">    <span class="keyword">bool</span> resultRight = <span class="built_in">isAVL</span>(pRoot-&gt;rchild, heightRighte);</span><br><span class="line">    <span class="keyword">if</span>(resultLeft &amp;&amp; resultRight &amp;&amp; <span class="built_in">abs</span>(heightLeft - heightRight) &lt;= <span class="number">1</span>) <span class="comment">// 左子树和右子树都是AVL，并且高度相差不大于1，返回真  </span></span><br><span class="line">    &#123;</span><br><span class="line">        height = <span class="built_in">max</span>(heightLeft, heightRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        height = <span class="built_in">max</span>(heightLeft, heightRight) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求二叉树的镜像">求二叉树的镜像</h3>
<p>递归解法：</p>
<ol>
<li>如果二叉树为空，返回空</li>
<li>如果二叉树不为空，求左子树和右子树的镜像，然后交换左子树和右子树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">mirror</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *pLeft = <span class="built_in">mirror</span>(pRoot-&gt;lchild); <span class="comment">// 求左子树镜像</span></span><br><span class="line">    Node *pRight = <span class="built_in">mirror</span>(pRoot-&gt;rchild); <span class="comment">// 求右子树镜像</span></span><br><span class="line">    <span class="comment">// 交换左子树和右子树</span></span><br><span class="line">    pRoot-&gt;lchild = pRight;</span><br><span class="line">    pRoot-&gt;rchild = pLeft;</span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="由前序遍历序列和中序遍历序列重建二叉树">由前序遍历序列和中序遍历序列重建二叉树</h3>
<p>二叉树前序遍历序列中，第一个元素总是树的根节点的值。中序遍历序列中，左子树的节点的值位于根节点的值的左边，右子树的节点的值位于根节点的值的右边。</p>
<p>递归解法：</p>
<ol>
<li>如果前序遍历为空或中序遍历为空或节点个数小于等于0，返回NULL。</li>
<li>创建根节点。前序遍历的第一个数据就是根节点的数据，在中序遍历中找到根节点的位置，可分别得知左子树和右子树的前序和中序遍历序列，重建左右子树。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">rebuildBinaryTree</span><span class="params">(<span class="keyword">int</span>* pPreOrder, <span class="keyword">int</span>* pInOrder, <span class="keyword">int</span> nodeNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pPreOrder == <span class="literal">NULL</span> || pInOrder == <span class="literal">NULL</span> || nodeNum &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Node *pRoot = <span class="keyword">new</span> Node;</span><br><span class="line">    <span class="comment">// 前序遍历的第一个数据就是根节点数据  </span></span><br><span class="line">    pRoot-&gt;data = pPreOrder[<span class="number">0</span>]; </span><br><span class="line">    pRoot-&gt;lchild = <span class="literal">NULL</span>;</span><br><span class="line">    pRoot-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找根节点在中序遍历中的位置，中序遍历中，根节点左边为左子树，右边为右子树</span></span><br><span class="line">    <span class="keyword">int</span> rootPositionInOrder = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodeNum; i++)</span><br><span class="line">        <span class="keyword">if</span>(pInOrder[i] == pRoot-&gt;data)</span><br><span class="line">        &#123;</span><br><span class="line">            rootPositionInOrder = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(rootPositionInOrder == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">exception</span>(<span class="string">&quot;Invalid input.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重建左子树  </span></span><br><span class="line">    <span class="keyword">int</span> nodeNumLeft = rootPositionInOrder;</span><br><span class="line">    <span class="keyword">int</span> * pPreOrderLeft = pPreOrder + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> * pInOrderLeft = pInOrder;</span><br><span class="line">    pRoot-&gt;lchild = <span class="built_in">rebuildBinaryTree</span>(pPreOrderLeft, pInOrderLeft, nodeNumLeft);</span><br><span class="line">    <span class="comment">// 重建右子树  </span></span><br><span class="line">    <span class="keyword">int</span> nodeNumRight = nodeNum - nodeNumLeft - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *pPreOrderRight = pPreOrder + <span class="number">1</span> + nodeNumLeft;</span><br><span class="line">    <span class="keyword">int</span> *pInOrderRight = pInOrder + nodeNumLeft + <span class="number">1</span>;</span><br><span class="line">    pRoot-&gt;rchild = <span class="built_in">rebuildBinaryTree</span>(pPreOrderRight, pInOrderRight, nodeNumRight);</span><br><span class="line">    <span class="keyword">return</span> pRoot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样，有中序遍历序列和后序遍历序列，类似的方法可重建二叉树，但<strong>前序遍历序列和后序遍历序列不能恢复一棵二叉树</strong>，证明略。</p>
<div class="alert alert-danger"><i class="fas fa-bug"></i>  前序遍历序列和后序遍历序列不能恢复一棵二叉树。
</div>
<h3 id="判断二叉树是不是完全二叉树">判断二叉树是不是完全二叉树</h3>
<p>若设二叉树的深度为h，除第 h 层外，其它各层（1～h-1）的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<p>有如下算法：按层次（从上到下，从左到右）遍历二叉树，当遇到一个节点的左子树为空时，则该节点右子树必须为空，且后面遍历的节点左右子树都必须为空，否则不是完全二叉树。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsCompleteBinaryTree</span><span class="params">(Node *pRoot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(pRoot);</span><br><span class="line">    <span class="keyword">bool</span> mustHaveNoChild = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        Node* pNode = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(mustHaveNoChild) <span class="comment">// 已经出现了有空子树的节点了，后面出现的必须为叶节点（左右子树都为空）  </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;lchild != <span class="literal">NULL</span> || pNode-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(pNode-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;rchild != <span class="literal">NULL</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                q.<span class="built_in">push</span>(pNode-&gt;lchild);  </span><br><span class="line">                q.<span class="built_in">push</span>(pNode-&gt;rchild);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; pNode-&gt;rchild == <span class="literal">NULL</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                mustHaveNoChild = <span class="literal">true</span>;  </span><br><span class="line">                q.<span class="built_in">push</span>(pNode-&gt;lchild);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(pNode-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; pNode-&gt;rchild != <span class="literal">NULL</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                result = <span class="literal">false</span>;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                mustHaveNoChild = <span class="literal">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="二叉查找树">二叉查找树</h3>
<p>如果我们给二叉树加一个额外的条件，就可以得到一种被称作二叉查找树(binary search tree)的特殊二叉树。二叉查找树要求：每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。</p>
<h4 id="插入节点">插入节点</h4>
<p>首先执行查找算法，找出被插结点的父亲结点。</p>
<p>判断被插结点是其父亲结点的左、右儿子。将被插结点作为叶子结点插入。</p>
<p>若二叉树为空。则首先单独生成根结点。</p>
<p>注意：新插入的结点总是叶子结点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(Node* &amp;pRoot, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        pRoot = <span class="keyword">new</span> Node;</span><br><span class="line">        pRoot-&gt;lchild = pRoot-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pRoot-&gt;data = x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; pRoot-&gt;data)</span><br><span class="line">        <span class="built_in">insertNode</span>(pRoot-&gt;lchild, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">insertNode</span>(pRoot-&gt;rchild, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除节点">删除节点</h4>
<p>删除某个结点后依然要保持二叉查找树的特性。例子中的删除过程如下：</p>
<ol>
<li>若删除点是叶子结点，则设置其双亲结点的指针为空。</li>
<li>若删除点只有左子树，或只有右子树，则设置其双亲结点的指针指向左子树或右子树。</li>
<li>若删除点的左右子树均不为空，则：
<ul>
<li>查询删除点的右子树的左子树是否为空，若为空，则把删除点的左子树设为删除点的右子树的左子树。</li>
<li>若不为空，则继续查询左子树，直到找到最底层的左子树为止。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(Node *root, <span class="keyword">int</span> data)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node p = *root, parent, s;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == p) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a leaf node</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;rchild &amp;&amp; !p-&gt;lchild) &#123;</span><br><span class="line">            *root = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the right child is NULL</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;rchild) &#123;</span><br><span class="line">            *root = p-&gt;lchild;</span><br><span class="line">            <span class="built_in">free</span>(p);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!p-&gt;lchild) &#123;</span><br><span class="line">            *root = p-&gt;rchild;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the node has both children</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            s = p-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span> (!s-&gt;lchild)</span><br><span class="line">            s-&gt;lchild = p-&gt;lchild;</span><br><span class="line">            <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="keyword">while</span> (s-&gt;lchild) &#123;  </span><br><span class="line">                parent = s;</span><br><span class="line">                s = s-&gt;lchild;</span><br><span class="line">            &#125;  </span><br><span class="line">            parent-&gt;lchild = s-&gt;rchild;</span><br><span class="line">            s-&gt;lchild = p-&gt;lchild;</span><br><span class="line">            s-&gt;rchild = p-&gt;rchild;</span><br><span class="line">            &#125;  </span><br><span class="line">            *root = s;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">deleteNode</span>(&amp;(p-&gt;rchild), data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; p-&gt;data) &#123;</span><br><span class="line">        <span class="built_in">deleteNode</span>(&amp;(p-&gt;lchild), data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h4 id="查找节点">查找节点</h4>
<p>递归解法：</p>
<ol>
<li>若当前节点为空，返回空节点；</li>
<li>若当前节点的值与要查找的值相同，返回当前节点；</li>
<li>若当前节点的值大于要查找的值，在左子树中继续查找该值；</li>
<li>若当前节点的值小于要查找的值，在右子树中继续查找该值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">searchNode</span><span class="params">(Node* &amp;pRoot, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (pRoot-&gt;data == x) <span class="keyword">return</span> pRoot;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; pRoot-&gt;data)</span><br><span class="line">        <span class="built_in">searchNode</span>(pRoot-&gt;lchild, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">searchNode</span>(pRoot-&gt;rchild, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希表">哈希表</h2>
<p>下图示意了哈希表（Hash Table）这样的数据结构。</p>
<p>
      <figure>
        <img src="//hahack-1253537070.file.myqcloud.com/images/blog/images/algorithms-data-structure/linkedlist.hashtab.png" alt="哈希表" />
        <figcaption>哈希表</figcaption>
      </figure>
    </p>
<p>如上图所示，首先分配一个指针数组，数组的每个元素是一个链表的头指针，每个链表称为一个 <strong>槽（Slot）</strong> 。哪个数据应该放入哪个槽中由哈希函数决定，在这个例子中我们简单地选取哈希函数h(x) = x % 11，这样任意数据x都可以映射成0~10之间的一个数，就是槽的编号，将数据放入某个槽的操作就是链表的插入操作。</p>
<p>如果每个槽里至多只有一个数据，可以想像这种情况下search、insert和delete操作的时间复杂度都是O(1)，但有时会有多个数据被哈希函数映射到同一个槽中，这称为碰撞（Collision），设计一个好的哈希函数可以把数据比较均匀地分布到各个槽中，<strong>尽量避免碰撞</strong>。如果能把n个数据比较均匀地分布到m个槽中，每个糟里约有n/m个数据，则search、insert和delete和操作的时间复杂度都是O(n/m)，如果n和m的比是常数，则时间复杂度仍然是O(1)。一般来说，要处理的数据越多，构造哈希表时分配的槽也应该越多，所以n和m成正比这个假设是成立的。</p>
<p>如果用我们学过的各种数据结构来表示n个数据的集合，下表是search、insert和delete操作在平均情况下的时间复杂度比较。</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>search</th>
<th>insert</th>
<th>delete</th>
</tr>
</thead>
<tbody>
<tr>
<td>数组</td>
<td>O(n)，有序数组折半查找是O(lgn)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>排序二叉树</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
</tr>
<tr>
<td>哈希表（n与槽数m成正比）</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h3 id="典型应用">典型应用</h3>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/shangshanhu/article/details/5917230">统计一个文本文件中每个单词的出现次数</a></li>
</ol>
<h2 id="深入阅读">深入阅读</h2>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/luckyxiaoqiang/article/details/7393134">轻松搞定面试中的链表题目</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/luckyxiaoqiang/article/details/7518888">轻松搞定面试中的二叉树题目</a></li>
</ol>


		<!-- pagination -->
		<div>
		  <center>
  		    <div class="pagination">
<ul class="pagination">
	
	
	
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
			
			
		
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	    
	
	
		<li class="prev"><a data-pjax href="/wiki/algorithm-bit.html" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>Prev</a></li>
	
	<li><a data-pjax href="/wiki"><i class="fa fa-tasks"></i>Wiki</a></li>
	
		<li class="next disabled"><a>Next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

	      </center>
		</div>
				
		<!-- comment -->
		
<section id="comment">
  <h2 class="title">Comments</h2>
  
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    if ($('#gt-container').length <= 0) {
    var gitalk = new Gitalk({
        clientID: '19f93019e0c0b8fdc4b3',
        clientSecret: '00ca18ff55f2b4f0f33af3fb90ff524e7acd1032',
        id: undefined != undefined ? 'undefined' : window.location.pathname,
        repo: 'wzpan.github.io',
        owner: 'wzpan',
        admin: 'wzpan',
        proxy: 'https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token',
        title: '数据结构'
    })
    gitalk.render('gitalk-container');
    }
  </script>
  
</section>

		

	</div> <!-- span9/span12 -->
</div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
    
    
    
    
          <div class="modal fade" id="wechat-modal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel">
            <div class="modal-dialog" role="document">
               <div class="modal-body">
                 <img src='https://hahack-1253537070.cos.ap-chengdu.myqcloud.com/images/blog/images/qrcode.jpg'/>
              </div>
            </div>
          </div>
		
    
    
    
  <footer> <p>
  &copy; 2021 wzpan
  
    <small>
     <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/3.0/deed.zh"><img title="知识共享许可协议" style="border-width: 0px; vertical-align: middle; display: inline; " src="/images/license.png"></a>
    </small>
</p>
 </footer>
  </div> <!-- container-narrow -->
  
<script type="text/x-mathjax-config">
   MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    }); 
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.imagesloaded.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/bootstrap.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/jquery.tableofcontents.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/tocgenerator.min.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/main.js"></script>
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/js/fadetoc.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="//hahack-1253537070.file.myqcloud.com/images/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = '/' + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>



  <script type="text/javascript">
    $(document).ready(function() {
      
         $("#freemind-cerulean").click(function(){
           document.cookie = "theme=cerulean; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=cerulean; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/cerulean.css");
         });
      
         $("#freemind-cyborg").click(function(){
           document.cookie = "theme=cyborg; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=cyborg; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/cyborg.css");
         });
      
         $("#freemind-paper").click(function(){
           document.cookie = "theme=paper; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=paper; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/paper.css");
         });
      
         $("#freemind-flatly").click(function(){
           document.cookie = "theme=flatly; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=flatly; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/flatly.css");
         });
      
         $("#freemind-journal").click(function(){
           document.cookie = "theme=journal; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=journal; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/journal.css");
         });
      
         $("#freemind-simplex").click(function(){
           document.cookie = "theme=simplex; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=simplex; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/simplex.css");
         });
      
         $("#freemind-spacelab").click(function(){
           document.cookie = "theme=spacelab; domain=www.hahack.com; maxAge=0";
           document.cookie = "theme=spacelab; domain=www.hahack.com";
           $("#theme").attr("href", "/css/themes/spacelab.css");
         });
      
     });
  </script>



<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>